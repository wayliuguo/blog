import{_ as l,o as i,c as a,U as e}from"./chunks/framework.9adb0f96.js";const t="/blog/html/image-20220820225124845.png",C=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/html.md","filePath":"interview/html.md","lastUpdated":1690176332000}'),s={name:"interview/html.md"},n=e(`<h2 id="_1-src-和-href-的区别" tabindex="-1">1.src 和 href 的区别 <a class="header-anchor" href="#_1-src-和-href-的区别" aria-label="Permalink to &quot;1.src 和 href 的区别&quot;">​</a></h2><p><strong>src 用于替换当前元素， href 用于在当前文档和引用资源之间确立联系</strong>。</p><ul><li>src <ul><li>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。</li><li><strong>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕</strong>，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js 脚本放在底部而不是头部。</li></ul></li><li>href <ul><li>指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。</li><li>并行下载资源并且不会停止对当前文档的处理，这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式</li></ul></li></ul><h2 id="_2-对-html-语义化的理解" tabindex="-1">2.对 html 语义化的理解 <a class="header-anchor" href="#_2-对-html-语义化的理解" aria-label="Permalink to &quot;2.对 html 语义化的理解&quot;">​</a></h2><ul><li><p>概念</p><ul><li>根据内容的结构化，选择适合的标签</li></ul></li><li><p>优点</p><ul><li>对机器友好，更适合搜索引擎的爬虫爬取有效信息，利于SEO。</li><li>对开发者友好，增加可读性，结构更加清晰，方便维护。</li></ul></li><li><p>常见的语义化标签：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;header&gt;&lt;/header&gt;头部</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;nav&gt;&lt;/nav&gt;导航栏</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;footer&gt;&lt;/footer&gt; 底部</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;aside&gt;&lt;/aside&gt;侧边栏</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;main&gt;&lt;/main&gt;主要区域</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;article&gt;&lt;/article&gt;主要内容</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;section&gt;&lt;/section&gt;区块（有语义的div）</span></span></code></pre></div></li></ul><h2 id="_3-doctype-文档类型-的作用" tabindex="-1">3. DOCTYPE(⽂档类型) 的作⽤ <a class="header-anchor" href="#_3-doctype-文档类型-的作用" aria-label="Permalink to &quot;3. DOCTYPE(⽂档类型) 的作⽤&quot;">​</a></h2><ul><li><strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档</strong></li><li><strong>CSS1Compat：标准模式（Strick mode）</strong></li><li><strong>BackCompat：怪异模式(混杂模式)(Quick mode)</strong></li></ul><h2 id="_4-script标签中defer和async的区别" tabindex="-1">4.script标签中defer和async的区别 <a class="header-anchor" href="#_4-script标签中defer和async的区别" aria-label="Permalink to &quot;4.script标签中defer和async的区别&quot;">​</a></h2><p><img src="`+t+`" alt="image-20220820225124845"></p><ul><li>蓝色代表js脚本网络加载时间</li><li>红色代表脚本执行时间</li><li>绿色代表html解析</li></ul><ol><li>没有 defer 或 async 属性 <ul><li>根据src的规则，浏览器会立即加载+执行js资源，暂停其他资源的加载和处理，所以阻塞了html解析。</li></ul></li><li>defer：延迟 <ul><li>js的加载与html的解析是并行的，但是js脚本不立刻执行，会等到html解析完成之后，DOMContentLoaded事件触发之前执行。</li></ul></li><li>async：异步 <ul><li>js的加载与html的解析是并行的，然后立即执行js脚本。</li></ul></li></ol><h2 id="_5-常用的meta标签" tabindex="-1">5. 常用的meta标签 <a class="header-anchor" href="#_5-常用的meta标签" aria-label="Permalink to &quot;5. 常用的meta标签&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 文档类型</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;meta charset=&quot;UTF-8&quot; &gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">// 关键词</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;meta name=&quot;keywords&quot; content=&quot;关键词&quot; /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">// 页面描述</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;meta name=&quot;description&quot; content=&quot;页面描述内容&quot; /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">// 页面重定向和刷新</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">// 视口</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</span></span></code></pre></div><ul><li><code>width viewport</code> ：宽度(数值/device-width)</li><li><code>height viewport</code> ：高度(数值/device-height)</li><li><code>initial-scale</code> ：初始缩放比例</li><li><code>maximum-scale</code> ：最大缩放比例</li><li><code>minimum-scale</code> ：最小缩放比例</li><li><code>user-scalable</code> ：是否允许用户缩放(yes/no）</li></ul><h2 id="_6-html5-有哪些更新" tabindex="-1">6. HTML5 有哪些更新？ <a class="header-anchor" href="#_6-html5-有哪些更新" aria-label="Permalink to &quot;6. HTML5 有哪些更新？&quot;">​</a></h2><ol><li><p>语义化标签</p></li><li><p>媒体标签</p><ul><li>video</li><li>audio</li></ul></li><li><p>表单</p><ul><li><p>表单类型</p><ul><li>email ：能够验证当前输入的邮箱地址是否合法</li><li>url ： 验证URL</li><li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li><li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li><li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li><li>color ： 提供了一个颜色拾取器</li><li>time ： 时分秒</li><li>date ： 日期选择年月日</li><li>datatime ： 时间和日期(目前只有Safari支持)</li><li>datatime-local ：日期时间控件</li><li>week ：周控件</li><li>month：月控件</li></ul></li><li><p>表单属性</p><ul><li><p>placeholder ：提示信息</p></li><li><p>autofocus ：自动获取焦点</p></li><li><p>autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：</p></li><li><ul><li>表单必须提交过</li><li>必须有name属性。</li></ul></li><li><p>required：要求输入框不能为空，必须有值才能够提交。</p></li><li><p>pattern=&quot; &quot; 里面写入想要的正则模式，例如手机号patte=&quot;^(+86)?\\d{10}$&quot;</p></li><li><p>multiple：可以选择多个文件或者多个邮箱</p></li><li><p>form=&quot; form表单的ID&quot;</p></li></ul></li><li><p>表单事件</p><ul><li>oninput 每当input里的输入框内容发生变化都会触发此事件。</li><li>oninvalid 当验证不通过时触发此事件。</li></ul></li></ul></li><li><p>进度条、度量器</p></li><li><p>DOM 查询操作</p><ul><li>document.querySelector()</li><li>document.querySelectorAll()</li></ul></li><li><p>Web 存储</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul></li><li><p>其他</p><ul><li>拖放</li><li>canvas</li></ul></li></ol><h2 id="_7-行内元素、块级元素" tabindex="-1">7.行内元素、块级元素 <a class="header-anchor" href="#_7-行内元素、块级元素" aria-label="Permalink to &quot;7.行内元素、块级元素&quot;">​</a></h2><ul><li>行内元素有：<code>a b span img input select strong</code>；</li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li></ul><h2 id="_8-iframe-有那些优点和缺点" tabindex="-1">8.<strong>iframe 有那些优点和缺点？</strong> <a class="header-anchor" href="#_8-iframe-有那些优点和缺点" aria-label="Permalink to &quot;8.**iframe 有那些优点和缺点？**&quot;">​</a></h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><p><strong>优点：</strong></p><ul><li>用来加载速度较慢的内容（如广告）</li><li>可以使脚本可以并行下载</li><li>可以实现跨子域通信</li></ul><p><strong>缺点：</strong></p><ul><li>iframe 会阻塞主页面的 onload 事件</li><li>无法被一些搜索引擎索识别</li><li>会产生很多页面，不容易管理</li></ul>`,24),o=[n];function r(p,c,u,d,h,m){return i(),a("div",null,o)}const _=l(s,[["render",r]]);export{C as __pageData,_ as default};
