import{_ as l,o as e,c as a,U as s}from"./chunks/framework.9adb0f96.js";const n="/blog/assets/Vue.a0530ac2.png",m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue.md","filePath":"interview/vue.md","lastUpdated":1691239651000}'),i={name:"interview/vue.md"},t=s('<p><img src="'+n+`" alt="Vue"></p><h2 id="vue" tabindex="-1">vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;vue&quot;">​</a></h2><h3 id="_1-vue2运行机制" tabindex="-1">1.vue2运行机制 <a class="header-anchor" href="#_1-vue2运行机制" aria-label="Permalink to &quot;1.vue2运行机制&quot;">​</a></h3><p>![mini-vue2 运行机制](vue.assets/mini-vue2 运行机制.png)</p><ol><li>initData: 遍历data属性，如果是数组或对象则递归遍历，对每个属性使用Object.defineProperty，同时生成一个dep实例，用于收集依赖与触发更新。</li><li>initWatcher: 遍历new Watcher,pushTarget(Dep.target 记录当前watcher，state记录watcher栈)，call 被监听属性，触发getter。 <ol><li>dep depend: dep.depend =》Dep.target.addDep(this) 调用当前watcher的addDep</li><li>watcher addDep: this.deps.push(dep) 往deps 存储dep，调用dep.addSub(this)</li><li>dep addSub: 往subs 存储 watcher</li></ol></li><li>模板解析：解析html模板，生成AST语法树=》生成渲染函数。</li><li>组件挂载：new Watcher, 记录渲染watcher，执行渲染函数(触发getter收集依赖)生成vnode,通过vnode的patch生成元素并挂载。</li><li>当第一次渲染后，如果修改了值，则会触发setter=》dep.notify =&gt; 把subs 中的每一个watcher 执行 update =》收集watcher 队列，nextTick 中 执行watcher.run 触发重新render与patch。</li></ol><h3 id="_2-双向绑定原理" tabindex="-1">2.双向绑定原理 <a class="header-anchor" href="#_2-双向绑定原理" aria-label="Permalink to &quot;2.双向绑定原理&quot;">​</a></h3><ol><li><p>使用<code>数据劫持</code>结合<code>发布订阅模式</code>实现。</p></li><li><p>对<code>data</code>数据进行递归遍历，加上setter和getter，生成一个dep实例用于收集依赖与触发更新。</p></li><li><p>compiler解析模板,生成AST语法树，生成render函数，执行render函数触发getter为数据添加订阅者watcher。绑定节点的更新函数，触发更改数据。</p></li><li><p>watcher 在数据更改后，dep通知watcher去执行其对应的回调函数，完成页面更新。</p></li></ol><h3 id="_3-object-defineproperty-的缺点" tabindex="-1">3.Object.defineProperty 的缺点 <a class="header-anchor" href="#_3-object-defineproperty-的缺点" aria-label="Permalink to &quot;3.Object.defineProperty 的缺点&quot;">​</a></h3><ul><li>对象新增属性无法劫持，必须改变整个对象重新劫持。</li><li>数组通过下标修改和其他操作，这里重写了内部方法，更改值后调用属性的dep.notify()发布更新通知。</li><li>vue3.0使用<code>proxy</code>对对象数组进行代理，从而实现数据劫持。唯一的缺点就是兼容性问题。</li></ul><h3 id="_4-mvvm" tabindex="-1">4.MVVM <a class="header-anchor" href="#_4-mvvm" aria-label="Permalink to &quot;4.MVVM&quot;">​</a></h3><ul><li>Model：数据模型，数据和业务逻辑在此定义</li><li>View: UI视图，负责数据的展示</li><li>ViewModel：负责监听Model中数据的改变并且控股之视图的更新，处理用户交互操作</li><li>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</li></ul><h3 id="_5-computed-和-watch-的区别" tabindex="-1">5.computed 和 watch 的区别？ <a class="header-anchor" href="#_5-computed-和-watch-的区别" aria-label="Permalink to &quot;5.computed 和 watch 的区别？&quot;">​</a></h3><ul><li><p>缓存</p><ul><li>computed 支持缓存，只有依赖的数据发生变化才会重新计算。</li><li>watch 不支持，数据变化就会触发操作</li></ul></li><li><p>异步</p><ul><li><p>computed 不支持异步（下方直接返回一个Promise）</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">asyncComputed() {</span></span>
<span class="line"><span style="color:#A6ACCD;">	return new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        	resolve(this.counter * 2)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }, 1000)</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span></code></pre></div></li><li><p>watch 支持（例如监听值变化发起请求）</p></li></ul></li><li><p>场景</p><ul><li>computed 用于数据计算，依赖于其他值时，利用缓存特性避免重新计算</li><li>watch 数据变化时异步或开销较大的操作。</li></ul></li><li><p>使用</p><ul><li>computed 默认getter，可以设置getter和setter</li><li>watch 可以设置 deep(深度监听)、immediate（加载组件立即触发）</li></ul></li></ul><h3 id="_6-slot" tabindex="-1">6.slot <a class="header-anchor" href="#_6-slot" aria-label="Permalink to &quot;6.slot&quot;">​</a></h3><ul><li><p>Vue 内容分发机制，是子组件的一个模板标签元素，其显示和如何显示由父组件决定。</p></li><li><p>slot分类</p><ul><li><p>默认插槽，没有指定name属性</p></li><li><p>具名插槽</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 定义</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;slot name=&#39;×××&#39;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 使用</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;template #×××&gt;&lt;/template&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;template v-slot:×××&gt;&lt;/template&gt;</span></span></code></pre></div></li><li><p>作用域插槽</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 定义</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;slot :item=&quot;item&quot; v-for=&quot;item in list&quot; /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 使用</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;list v-slot=&quot;props&quot;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	&lt;span&gt;{{props.item}}&lt;/span&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/list&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">// 使用（解构）</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;list v-slot=&quot;{item}&quot;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	&lt;span&gt;{{item}}&lt;/span&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/list&gt;</span></span></code></pre></div></li></ul></li><li><p>原理</p><ul><li>组件实例化时获取父组件传入的slot标签内容，存放在<code>vm.$slot</code>中</li><li>执行渲染函数时，遇到slot标签，用<code>vm.$slot</code>中的内容进行替换</li></ul></li></ul><h3 id="_7-如何保存页面当前状态" tabindex="-1">7.如何保存页面当前状态 <a class="header-anchor" href="#_7-如何保存页面当前状态" aria-label="Permalink to &quot;7.如何保存页面当前状态&quot;">​</a></h3><p>A=&gt; B B=&gt;A :只有从B页面返回A页面，A页面才使用原来的状态</p><ul><li><p>前组件卸载</p><ul><li><p>使用<code>localStorage/sessionStorage</code>存储</p><ul><li>优点：兼容性好，简单</li><li>缺点：数据JSON化的时候需要考虑兼容情况（Date对象等），需要增加flag判断。</li></ul></li><li><p>使用<code>vuex</code>存储</p></li><li><p>需要记录从哪个页面而来，可以使用VueRouter守卫来获取</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// main.js</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Vue.prototype.$previousRoute = null</span></span>
<span class="line"><span style="color:#A6ACCD;">router.beforeEach((to, from, next) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  Vue.prototype.$previousRoute = from</span></span>
<span class="line"><span style="color:#A6ACCD;">  next()</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">new Vue({</span></span>
<span class="line"><span style="color:#A6ACCD;">  router,</span></span>
<span class="line"><span style="color:#A6ACCD;">  store,</span></span>
<span class="line"><span style="color:#A6ACCD;">  render: h =&gt; h(App)</span></span>
<span class="line"><span style="color:#A6ACCD;">}).$mount(&#39;#app&#39;)</span></span></code></pre></div></li></ul></li><li><p>前组件不卸载</p><ul><li><p>keep-alive</p><ul><li>activated</li><li>deactivated</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;keep-alive</span></span>
<span class="line"><span style="color:#A6ACCD;">    :include=&quot;include&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    :exclude=&quot;exclude&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    :max=&quot;max&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	&lt;router-view /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/keep-alive&gt;</span></span></code></pre></div></li></ul></li></ul><h3 id="_8-常见事件修饰符" tabindex="-1">8.常见事件修饰符 <a class="header-anchor" href="#_8-常见事件修饰符" aria-label="Permalink to &quot;8.常见事件修饰符&quot;">​</a></h3><ul><li>.stop 等同于<code>event.stopPropagation()</code>，防止冒泡</li><li>.prevent 等同于<code>event.preventDefault</code> 阻止默认行为</li><li>.capture: 与事件冒泡方向相反</li><li>.self: 只触发自己范围内的事件，不包含子元素</li><li>.once: 只触发一次</li></ul><h3 id="_9-v-if、v-show、v-html原理" tabindex="-1">9.v-if、v-show、v-html原理 <a class="header-anchor" href="#_9-v-if、v-show、v-html原理" aria-label="Permalink to &quot;9.v-if、v-show、v-html原理&quot;">​</a></h3><ul><li>v-if 生成vnode的时候忽略对应节点，render的时候就不会渲染</li><li>v-show 正常生成vnode，render时候渲染真实节点，render过程中根据show的属性值修改<code>display</code></li><li>设置节点的innerHTML 属性为 v-html 的值</li></ul><h3 id="_10-v-if和v-show的区别" tabindex="-1">10.v-if和v-show的区别 <a class="header-anchor" href="#_10-v-if和v-show的区别" aria-label="Permalink to &quot;10.v-if和v-show的区别&quot;">​</a></h3><ul><li>手段：v-if 动态添加删除DOM元素，v-show动态修改display属性</li><li>编译条件：v-if 只有真时才编译生成DOM，v-show无论真假都会编译DOM</li><li>性能消耗: v-if 更高的切换消耗 v-show 更高的初始渲染消耗</li><li>使用场景：v-show 适合频繁切换 v-if 相反</li></ul><h3 id="_11-v-model-语法糖" tabindex="-1">11.v-model 语法糖 <a class="header-anchor" href="#_11-v-model-语法糖" aria-label="Permalink to &quot;11.v-model 语法糖&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;CustomInput v-model=&quot;searchText&quot;/&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;CustomInput</span></span>
<span class="line"><span style="color:#A6ACCD;">  :value=&quot;searchText&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  @input=&quot;newValue =&gt; searchText = newValue&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">/&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">emit(&#39;input&#39;, ×××)</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 默认</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;CustomInput v-model=&quot;searchText&quot;/&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;CustomInput</span></span>
<span class="line"><span style="color:#A6ACCD;">  :modelValue=&quot;searchText&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">/&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">emit(&#39;update:modelValue&#39;, ×××)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 自定义绑定属性</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;MyComponent </span></span>
<span class="line"><span style="color:#A6ACCD;">  :title=&quot;bookTitle&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  @update:title=&quot;newValue =&gt; bookTitle = newValue&quot; </span></span>
<span class="line"><span style="color:#A6ACCD;">/&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">$emit(&#39;update:title&#39;, ×××)</span></span></code></pre></div><h3 id="_12-data-为什么是一个函数而不是一个对象" tabindex="-1">12. data 为什么是一个函数而不是一个对象 <a class="header-anchor" href="#_12-data-为什么是一个函数而不是一个对象" aria-label="Permalink to &quot;12. data 为什么是一个函数而不是一个对象&quot;">​</a></h3><ul><li>对象是引用类型，会被所有实例化的组件所共享，导致他们引用同一个数据对象</li><li>采用函数的形式，再initData的时候将其作为工厂函数提供全新的对象</li></ul><h3 id="_13-nexttick-的原理及作用" tabindex="-1">13.$nextTick 的原理及作用 <a class="header-anchor" href="#_13-nexttick-的原理及作用" aria-label="Permalink to &quot;13.$nextTick 的原理及作用&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">let callbacks = []</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">function flushCallbacks () {</span></span>
<span class="line"><span style="color:#A6ACCD;">    callbacks.forEach(cb =&gt; cb())</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">let timerFunc</span></span>
<span class="line"><span style="color:#A6ACCD;">let waiting = false</span></span>
<span class="line"><span style="color:#A6ACCD;">if (Promise) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    timerFunc = () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        Promise.resolve().then(flushCallbacks)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">} else if (MutationObserver) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let observe = new MutationObserver(flushCallbacks)</span></span>
<span class="line"><span style="color:#A6ACCD;">    let textNode = document.createTextNode(1)</span></span>
<span class="line"><span style="color:#A6ACCD;">    observe.observe(textNode, {</span></span>
<span class="line"><span style="color:#A6ACCD;">        characterData: true</span></span>
<span class="line"><span style="color:#A6ACCD;">    })</span></span>
<span class="line"><span style="color:#A6ACCD;">    timerFunc = () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        textNode.textContent = 2</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">} else if (setImmediate) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    timerFunc = () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        setImmediate(flushCallbacks)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">} else {</span></span>
<span class="line"><span style="color:#A6ACCD;">    timerFunc = () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        setTimeout(flushCallbacks, 0)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">export function nextTick (cb) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    callbacks.push(cb)</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (!waiting) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        timerFunc()</span></span>
<span class="line"><span style="color:#A6ACCD;">        waiting = true</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><ul><li>nextTick 所在作用域维护一个回调函数的栈</li><li>利用 <code>Promise、MutationObserver、setImmediate、setTimeout</code>，这里Promise是属于微任务，可以在同一事件循环迭代当前宏任务结束之后立即执行，其他的是宏任务，在下一事件循环中执行。所以这里Promise优先级更高</li><li>引入这种异步更新机制的原因 <ul><li>同步更新会频繁触发DOM渲染（减少渲染）</li><li>由于虚拟DOM，状态的变更会导致频繁计算（减少计算）</li></ul></li></ul><h3 id="_14-给对象添加新属性" tabindex="-1">14.给对象添加新属性 <a class="header-anchor" href="#_14-给对象添加新属性" aria-label="Permalink to &quot;14.给对象添加新属性&quot;">​</a></h3><ul><li>视图没有更新，因为属性没有被转换为响应式数据（没有收集依赖）</li><li>this.$set(target, key, value)</li></ul><h3 id="_15-vue-template-到-render-过程" tabindex="-1">15.Vue template 到 render 过程 <a class="header-anchor" href="#_15-vue-template-到-render-过程" aria-label="Permalink to &quot;15.Vue template 到 render 过程&quot;">​</a></h3><p><strong>template =&gt; ast(抽象语法树) =&gt; render 函数</strong></p><h3 id="_16-vue中封装的数组方法有哪些-如何实现页面更新" tabindex="-1">16.vue中封装的数组方法有哪些？如何实现页面更新 <a class="header-anchor" href="#_16-vue中封装的数组方法有哪些-如何实现页面更新" aria-label="Permalink to &quot;16.vue中封装的数组方法有哪些？如何实现页面更新&quot;">​</a></h3><ul><li>数组 <ul><li>push</li><li>pop</li><li>shift</li><li>unshift</li><li>splice</li><li>sort</li><li>reverse</li></ul></li><li>调用后返回结果之前，通过dep.notify()触发依赖更新。</li></ul><h3 id="_17-自定义指令" tabindex="-1">17.自定义指令 <a class="header-anchor" href="#_17-自定义指令" aria-label="Permalink to &quot;17.自定义指令&quot;">​</a></h3><ul><li>对普通DOM元素进行底层操作</li><li>钩子函数（vue2） <ul><li>bind</li><li>inserted</li><li>update</li><li>ComponentUpdate</li><li>unbind</li></ul></li><li>钩子函数（vue3) <ul><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>beforeUnmount</li><li>unmounted</li></ul></li></ul><h3 id="_18-子组件可以直接改变父组件数据吗" tabindex="-1">18.子组件可以直接改变父组件数据吗？ <a class="header-anchor" href="#_18-子组件可以直接改变父组件数据吗" aria-label="Permalink to &quot;18.子组件可以直接改变父组件数据吗？&quot;">​</a></h3><ul><li>只可以父级 props 更新留向子组件，每次更新时子组件中所有props都会刷新</li><li>防止意外改变父组件状态，增加degger成本</li><li>只能通过<code>$emit</code>派发自定义事件由父组件修改</li></ul><h3 id="_19-v-if-和-v-for-优先级" tabindex="-1">19.v-if 和 v-for 优先级 <a class="header-anchor" href="#_19-v-if-和-v-for-优先级" aria-label="Permalink to &quot;19.v-if 和 v-for 优先级&quot;">​</a></h3><ul><li>v-fo 优先级更高</li><li>在循环中根据v-if 来确定是否渲染该元素，如果v-if 是假，则跳过</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;div v-for=&quot;item in items&quot; v-if=&quot;item.isActive&quot;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  {{ item.name }}</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/div&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">// 在上述示例中，v-for会遍历items数组中的每个元素，并且只有当item.isActive为真时，才会渲染对应的&lt;div&gt;元素。</span></span></code></pre></div><ul><li>vue2 中 v-for &gt; v-if</li><li>vue3 中 v-if &gt; v-for</li></ul><h3 id="_20-vue初始化页面闪动问题" tabindex="-1">20.vue初始化页面闪动问题 <a class="header-anchor" href="#_20-vue初始化页面闪动问题" aria-label="Permalink to &quot;20.vue初始化页面闪动问题&quot;">​</a></h3><p>代码还没解析好看到模板的问题</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">[v-cloak] {</span></span>
<span class="line"><span style="color:#A6ACCD;">  display: none;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><h3 id="_21-spa-优缺点" tabindex="-1">21. SPA 优缺点 <a class="header-anchor" href="#_21-spa-优缺点" aria-label="Permalink to &quot;21. SPA 优缺点&quot;">​</a></h3><ul><li><p>SPA</p><p>页面初始化时加载相应资源，加载完成后不会因为用户操作进行页面的重新加载和跳转，利用路由机制实现内容变化与交互。</p></li><li><p>优点</p><ul><li>体验好，内容变化不需要重新加载，避免不必要的跳转和重复渲染</li><li>服务器压力小</li><li>前后端职责分离</li></ul></li><li><p>缺点</p><ul><li>白屏时间长</li><li>前端需要自行建立路由管理</li><li>SEO难度大：所有内容在一个页面中动态替换显示</li></ul></li></ul><h3 id="_22-虚拟dom" tabindex="-1">22. 虚拟DOM <a class="header-anchor" href="#_22-虚拟dom" aria-label="Permalink to &quot;22. 虚拟DOM&quot;">​</a></h3><ul><li>通过js对象的方式描述DOM结构</li><li>优点 <ul><li>跨平台</li><li>性能优化，收集变更再对比刷新</li><li>简化开发，无需操作真是DOM</li></ul></li></ul><h3 id="_23-diff-算法" tabindex="-1">23. diff 算法 <a class="header-anchor" href="#_23-diff-算法" aria-label="Permalink to &quot;23. diff 算法&quot;">​</a></h3><ol><li>标签名不一样，直接替换</li><li>如果标签一样比较属性</li><li>比较双方儿子 <ul><li>老的没儿子新的有儿子循环创建</li><li>老的有儿子新的没儿子删除老节点</li><li>双方都有儿子节点，双指针比较 <ul><li>oldStartIndex：旧头下标，oldStartVnode</li><li>oldEndIndex: 旧尾下标，oldEndVnode</li><li>newStartIndex：新头下标，newStartVnode</li><li>newEndIndex:：新尾下标，newEndVnode</li><li>头头比较，如果相同头开始指针后移，更新对应的vnode</li><li>尾尾比较，如果相同结束指针前移，更新对应的vnode</li><li>旧头新尾比较，如果相同，旧头后移新尾前移</li><li>旧尾新后比较，如果相同，旧尾前移新头后移</li><li>乱序比较 <ul><li>通过旧列表创建key=》index映射，通过新头指针对应节点的key找到对应的index</li><li>如果找不到，直接创建新的节点插入老节点的头指针处</li><li>如果找到，移动该节点到旧头指针处</li></ul></li></ul></li><li>如果一方有一方没有 <ul><li>新的还有旧的没有</li><li>旧的还有新的没有</li></ul></li></ul></li></ol><h3 id="_24-key-的作用" tabindex="-1">24. key 的作用 <a class="header-anchor" href="#_24-key-的作用" aria-label="Permalink to &quot;24. key 的作用&quot;">​</a></h3><p>作为vnode的唯一标记，可以使diff操作更准确与高效，确保数据更新时进行最小化的DOM操作与正确的节点重用。</p><h3 id="_25-vue生命周期" tabindex="-1">25.vue生命周期 <a class="header-anchor" href="#_25-vue生命周期" aria-label="Permalink to &quot;25.vue生命周期&quot;">​</a></h3><p>开始创建=》初始化数据=》模板编译=》挂载DOM=&gt;渲染更新=》渲染、卸载一系列流程</p><ol><li>beforeCreate <ul><li>数据观察和初始化事件还没开始，无法访问到data、computed等数据和方法</li></ul></li><li>created <ul><li>实例创建完成，已经可以访问data等数据和方法，但是没有挂载到DOM</li></ul></li><li>beforeMount <ul><li>挂载之前被调用，已经对模板解析得到了render函数</li></ul></li><li>mounted <ul><li>完成了调用render函数生成vnode，把vnode转换成html替换内容</li></ul></li><li>beforeUpdate <ul><li>响应式数据更新时调用，UI还没更新</li></ul></li><li>updated <ul><li>UI已经更新</li></ul></li><li>beforeDestory <ul><li>实例销毁前调用,服务端渲染不被调用</li></ul></li><li>destoryed <ul><li>实例销毁后调用，服务端渲染不被调用</li></ul></li></ol><h3 id="_26-父子组件执行顺序" tabindex="-1">26.父子组件执行顺序 <a class="header-anchor" href="#_26-父子组件执行顺序" aria-label="Permalink to &quot;26.父子组件执行顺序&quot;">​</a></h3><ul><li><p>加载渲染过程</p><ol><li>父组件 beforeCreate</li><li>父组件 created</li><li>父组件 beforeMount</li><li>子组件 beforeCreate</li><li>子组件 created</li><li>子组件 beforeMount</li><li>子组件 mounted</li><li>父组件 mounted</li></ol></li><li><p>更新过程</p><ol><li>父组件 beforeUpdate</li><li>子组件 beforeCreate</li><li>子组件 updated</li><li>父组件 updated</li></ol></li><li><p>销毁</p><ol><li>父组件 beforeDestory</li><li>子组件 beforeDestory</li><li>子组件 destoryed</li><li>父组件 destoryed</li></ol></li></ul><h3 id="_27-组件通信" tabindex="-1">27.组件通信 <a class="header-anchor" href="#_27-组件通信" aria-label="Permalink to &quot;27.组件通信&quot;">​</a></h3><ul><li><p>父子组件传值（props/$emit）</p></li><li><p>eventBus事件总线（$emit/$on）</p><ol><li><p>创建事件中心</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">import Vue from &#39;vue&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">export const EventBus = new Vue()</span></span></code></pre></div></li><li><p>发送事件</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">import {EventBus} from &#39;./event-bus.js&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">EventBus.$emit(&#39;×××&#39;, {...})</span></span></code></pre></div></li><li><p>接收事件</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">import {EventBus} from &#39;./event-bus.js&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">EventBus.$on(&#39;×××&#39;, {...})</span></span></code></pre></div></li></ol></li><li><p>依赖注入（provide/inject）</p></li><li><p>ref / $refs</p></li><li><p>$parent / $children</p></li><li><p>$attrs/$listeners (A=&gt;B=&gt;C 跨代传递)</p><ul><li><code>inheritAttrs</code>默认只继承除<code>pros</code>外的所有属性，如果为<code>false</code>则只继承<code>class</code>属性</li><li><code>$attrs</code>继承所有的父组件属性（除props、class、style）(v-bind=&quot;$attrs&quot;)</li><li><code>$listeners</code>继承所有父组件的自定义监听器（v-on=&quot;$listeners&quot;）</li></ul></li></ul><h2 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h2><h3 id="vue3新特性" tabindex="-1">vue3新特性 <a class="header-anchor" href="#vue3新特性" aria-label="Permalink to &quot;vue3新特性&quot;">​</a></h3><ol><li>性能提升 <ul><li>响应式性能提升</li><li>diff算法优化（增加静态标志）</li><li>模板编译优化，不参与更新元素只创建一次</li><li>更高效组件初始化</li></ul></li><li>更好的ts支持，提供了更好的类型检查</li><li>Composition API <ul><li>更好的代码组织形式，避免来回切换</li><li>更好的组件件代码复用，避免vue2 mixin的变量冲突、来源不清晰的缺点</li></ul></li><li>新增组件 <ul><li>Fragment：不再限制<code>template</code>只有一个根节点</li><li>Teleport：传送门，允许我们将控制的内容传送到任意的 <code>DOM</code> 中</li><li>Suspense：等待异步组件时渲染一些额外的内容，让应用有更好的用户体验</li></ul></li></ol><h3 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h3><ul><li>初始化阶段：初始化阶段通过组件初始化方法形成对应的<code>proxy对象</code>，然后形成一个负责渲染的<code>effect</code></li><li>get依赖收集阶段：通过<code>解析template</code>，替换<code>真实data</code>属性，来触发<code>get</code>,然后通过<code>track方法</code>，通过<code>proxy对象</code>和<code>key</code>形成对应的<code>deps</code>，将负责渲染的<code>effect</code>存入<code>deps</code></li><li>set 派发更新阶段：触发<code>setter</code>的时候通过<code>effect</code>通知<code>effect</code>更新</li></ul><h3 id="v-if、v-for-优先级" tabindex="-1">v-if、v-for 优先级 <a class="header-anchor" href="#v-if、v-for-优先级" aria-label="Permalink to &quot;v-if、v-for 优先级&quot;">​</a></h3><p><code>v-if</code>的优先级更高。</p><h3 id="setup" tabindex="-1">setup <a class="header-anchor" href="#setup" aria-label="Permalink to &quot;setup&quot;">​</a></h3><ul><li>属性和方法无需返回，可以直接使用</li><li>引入组件自动注册</li><li>使用<code>defineProps</code>接收父组件传递值,defineEmits 获取自定义事件。</li><li>useAttrs 获取属性，useSlots 获取插槽。</li><li>默认<code>不会对外暴露</code>任何属性，如果有需要可使用 <code>defineExpose</code></li></ul><h3 id="通信方式" tabindex="-1">通信方式 <a class="header-anchor" href="#通信方式" aria-label="Permalink to &quot;通信方式&quot;">​</a></h3><ul><li>props/$emit</li><li>expose/ref</li><li>$attrs</li><li>provide/inject</li><li>mitt</li></ul><h3 id="ref-与-reactived的区别" tabindex="-1">ref 与 reactived的区别？ <a class="header-anchor" href="#ref-与-reactived的区别" aria-label="Permalink to &quot;ref 与 reactived的区别？&quot;">​</a></h3><ul><li>ref 在js中需要通过.value 使用</li><li>ref 可以接收原始数据类型和引用数据类型，其判断是非原始数据类型使用reactive封装</li><li>reactive 只能接收引用数据类型</li></ul><h2 id="vuerouter" tabindex="-1">vueRouter <a class="header-anchor" href="#vuerouter" aria-label="Permalink to &quot;vueRouter&quot;">​</a></h2><h3 id="路由懒加载" tabindex="-1">路由懒加载 <a class="header-anchor" href="#路由懒加载" aria-label="Permalink to &quot;路由懒加载&quot;">​</a></h3><p>使用箭头函数+import</p><h3 id="_1-hash和history模式" tabindex="-1">1.hash和history模式 <a class="header-anchor" href="#_1-hash和history模式" aria-label="Permalink to &quot;1.hash和history模式&quot;">​</a></h3><ol><li><p>原理</p><ul><li>hash: hashchange</li><li>history: pushState、replaceState</li></ul></li><li><p>特点：</p><ul><li>hash值出现在url里面，改变hash值不会重新加载页面，兼容性好</li><li>比hash值好看，需要后端服务器配置正确的入口文件避免出现404</li></ul></li></ol><h3 id="_2-route-和-router-区别" tabindex="-1">2.$route 和 $router 区别 <a class="header-anchor" href="#_2-route-和-router-区别" aria-label="Permalink to &quot;2.$route 和 $router 区别&quot;">​</a></h3><ul><li>$route：路由信息对象，包括 path、params、hash、name、query等信息</li><li>$router：路由实例，包括路由的跳转方法</li></ul><h3 id="_3-动态路由" tabindex="-1">3.动态路由 <a class="header-anchor" href="#_3-动态路由" aria-label="Permalink to &quot;3.动态路由&quot;">​</a></h3><ol><li><p>param</p><ul><li><p>配置：/router/:id</p></li><li><p>跳转</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;router-link :to=&quot;{name: &#39;users&#39;, params: {...}}&quot;&gt;replace 用户&lt;/router-link&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">this.$router.push({name: &#39;users&#39;, params:{}})</span></span></code></pre></div></li><li><p>参数获取：this.$route.params.userid</p></li></ul></li><li><p>query</p><ul><li><p>配置：/router</p></li><li><p>跳转</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;router-link :to=&quot;{name: &#39;users&#39;, query: {...}}&quot;&gt;replace 用户&lt;/router-link&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">this.$router.push({name: &#39;users&#39;, query:{}})</span></span></code></pre></div></li><li><p>参数获取：this.$route.query</p></li></ul></li><li><p>区别：params在浏览器地址中不显示参数，刷新会丢失路由数据</p></li></ol><h3 id="_4-生命周期" tabindex="-1">4.生命周期 <a class="header-anchor" href="#_4-生命周期" aria-label="Permalink to &quot;4.生命周期&quot;">​</a></h3><ul><li><p>全局路由钩子</p><ul><li>router.beforeEach: 路由切换时触发，用于是否允许路由切换</li><li>router.beforeResolve：路由解析完成前，用于额外逻辑处理如加载数据、修改参数</li><li>router.afterEach: 进入路由之后</li></ul></li><li><p>路由独享钩子</p><ul><li>beforeEnter: 进入某个具体路由前执行</li></ul></li><li><p>组件内守卫</p><ul><li>beforeRouteEnter：进入组件前触发，不能获取this</li><li>beforeRouteUpdate：当前地址改变并且组件被服用触发，如foo/:id</li><li>beforeRouteLeave：离开组件被调用</li></ul></li><li><p>完整的导航解析流程</p><ol><li>导航被触发</li><li>在失活的组件里调用 beforeRouteLeave</li><li>调用全局 beforeEach</li><li>重用的组件调用 beforeRouteUpdate</li><li>路由配置调用 beforeEnter</li><li>解析异步路由组件</li><li>被激活的组件调用 beforeRouterEnter</li><li>调用全局 beforeResolve</li><li>导航被确认</li><li>调用全局的 afterEach</li><li>触发 DOM 更新</li><li>调用 beforeRouteEnter中next</li></ol></li></ul><h2 id="存储" tabindex="-1">存储 <a class="header-anchor" href="#存储" aria-label="Permalink to &quot;存储&quot;">​</a></h2><h3 id="vuex" tabindex="-1">vuex <a class="header-anchor" href="#vuex" aria-label="Permalink to &quot;vuex&quot;">​</a></h3><ul><li><p>属性</p><ul><li>state</li><li>getters</li><li>mutations</li><li>actions</li><li>modules</li></ul></li><li><p>操作方法</p><ul><li>commit 提交 mutation</li><li>dispatch 提交 action</li></ul></li><li><p>思想</p><ul><li>单一数据源</li><li>变化可以预测</li></ul></li><li><p>辅助函数</p><ul><li>mapState</li><li>mapGetters</li><li>mapMutations</li><li>mapActions</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">computed: {</span></span>
<span class="line"><span style="color:#A6ACCD;">	...mapState([&#39;name&#39;]),</span></span>
<span class="line"><span style="color:#A6ACCD;">    ...mapGetters([&#39;myAge&#39;])</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">methods: {</span></span>
<span class="line"><span style="color:#A6ACCD;">	...mapMutations([&#39;changeAge&#39;])</span></span>
<span class="line"><span style="color:#A6ACCD;">    ...mapActions([&#39;changeAge&#39;])</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div></li></ul><h3 id="pina" tabindex="-1">pina <a class="header-anchor" href="#pina" aria-label="Permalink to &quot;pina&quot;">​</a></h3><ul><li><p>属性</p><ul><li>state：setup: <code>ref()</code> 就是 <code>state</code> 属性</li><li>getters：setup:<code>computed()</code> 就是 <code>getters</code></li><li>actions：setup:<code>function()</code> 就是 <code>actions</code></li></ul></li><li><p>定义 defineStore</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">export const useAlertsStore = defineStore(&#39;alerts&#39;, {</span></span>
<span class="line"><span style="color:#A6ACCD;">  state: () =&gt; {},</span></span>
<span class="line"><span style="color:#A6ACCD;">  getters: {},</span></span>
<span class="line"><span style="color:#A6ACCD;">  actions: {}</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">export const useCounterStore = defineStore(&#39;counter&#39;, () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  const count = ref(0)</span></span>
<span class="line"><span style="color:#A6ACCD;">  function increment() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">  return { count, increment }</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span></code></pre></div></li><li><p>使用</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 使用</span></span>
<span class="line"><span style="color:#A6ACCD;">const store = useCounterStore()</span></span>
<span class="line"><span style="color:#A6ACCD;">// 解构 state 需要使用 storeToRefs</span></span>
<span class="line"><span style="color:#A6ACCD;">const { name, doubleCount } = storeToRefs(store)</span></span>
<span class="line"><span style="color:#A6ACCD;">// 解构 action 可以直接解构</span></span>
<span class="line"><span style="color:#A6ACCD;">const { increment } = store</span></span></code></pre></div></li></ul>`,93),o=[t];function p(r,c,u,d,h,C){return e(),a("div",null,o)}const v=l(i,[["render",p]]);export{m as __pageData,v as default};
