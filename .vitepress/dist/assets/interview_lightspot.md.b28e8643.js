import{_ as i,o as l,c as e,U as a}from"./chunks/framework.9adb0f96.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/lightspot.md","filePath":"interview/lightspot.md","lastUpdated":1695218549000}'),t={name:"interview/lightspot.md"},o=a('<h2 id="完整的权限权力方案" tabindex="-1">完整的权限权力方案 <a class="header-anchor" href="#完整的权限权力方案" aria-label="Permalink to &quot;完整的权限权力方案&quot;">​</a></h2><ul><li>接口权限，配合 axios 控制</li><li>按钮权限，配合指令实现</li><li>权限函数</li><li>路由权限，配合路由钩子实现</li></ul><h2 id="适配不同尺寸设备" tabindex="-1">适配不同尺寸设备 <a class="header-anchor" href="#适配不同尺寸设备" aria-label="Permalink to &quot;适配不同尺寸设备&quot;">​</a></h2><ul><li>postcss-px-to-viewport</li></ul><h2 id="业务复杂-有许多相同的业务代码-代码量多" tabindex="-1">业务复杂，有许多相同的业务代码，代码量多 <a class="header-anchor" href="#业务复杂-有许多相同的业务代码-代码量多" aria-label="Permalink to &quot;业务复杂，有许多相同的业务代码，代码量多&quot;">​</a></h2><ul><li>商品模块就包括了颜色、尺寸、分类、品牌、季节、设计师、表格、文件上传、预览、下载组件</li><li>统一的表格行列生成逻辑抽离、输入校验等</li><li>组件封装原则 <ol><li>单一责任原则 (Single Responsibility Principle, SRP)：组件应该关注于单一的功能或责任，并且只有一个引起变化的原因。这使得组件更加独立、可维护，能够更容易理解和修改。</li><li>开放封闭原则 (Open-Closed Principle, OCP)：组件应该对扩展开放，对修改关闭。通过定义清晰的接口和抽象，我们可以在不修改现有组件的情况下进行功能扩展，提高代码的稳定性和可扩展性。</li><li>组合原则 (Composition Principle)：通过将小型、可组合的组件组合成更大的组件或应用，实现功能的复用和组合。这种组件设计方式促进了模块化和组合性，使得代码更易于管理和维护。</li><li>接口隔离原则 (Interface Segregation Principle, ISP)：组件应该依赖于最小化和专注的接口，而不是臃肿的接口。这样可以减少组件之间的依赖，提高组件的独立性和可测试性。</li><li>信息隐藏原则 (Information Hiding Principle)：组件应该隐藏其内部实现细节，只暴露必要的接口和功能。这样可以降低组件之间的耦合度，并提供更好的封装和抽象。</li><li>单向数据流 (One-Way Data Flow)：组件应该通过明确的数据流动方向来管理状态和数据的变化。这种设计方式使得代码更加可预测、可维护，并且易于调试。</li><li>可配置性 (Configurability)：组件应该具备一定程度的可配置性，以适应不同的使用场景和需求。通过参数化组件的行为和外观，可以提高组件的灵活性和复用性。</li><li>高内聚低耦合 (High Cohesion, Low Coupling)：组件内部的元素应该紧密相关，彼此协作，形成高内聚性。同时，组件之间的依赖应该尽量减少，以达到低耦合性。这促进了代码的模块化和可维护性。</li></ol></li></ul><h2 id="大文件上传进度缓慢" tabindex="-1">大文件上传进度缓慢 <a class="header-anchor" href="#大文件上传进度缓慢" aria-label="Permalink to &quot;大文件上传进度缓慢&quot;">​</a></h2><ul><li>对文件进行<code>hash</code>，判断是否已经上传过，实现妙传</li><li>使用 <code>splice</code> 对文件进行切片，每次调用后端的 <code>upload_chunk</code> 接口上传 切片</li><li>在都成功后调用 <code>upload_merge</code> 进行文件合并</li></ul><h2 id="大数据列表卡顿问题" tabindex="-1">大数据列表卡顿问题 <a class="header-anchor" href="#大数据列表卡顿问题" aria-label="Permalink to &quot;大数据列表卡顿问题&quot;">​</a></h2><ul><li>封装虚拟滚动组件进行优化</li></ul><h2 id="解决-ios-兼容性问题" tabindex="-1">解决 ios 兼容性问题 <a class="header-anchor" href="#解决-ios-兼容性问题" aria-label="Permalink to &quot;解决 ios 兼容性问题&quot;">​</a></h2><ul><li>安全区</li><li>new Date</li><li>点击响应缓慢</li><li>分享朋友圈图片太大出错</li><li>隐私政策没有配置到权限</li></ul><h3 id="小程序" tabindex="-1">小程序 <a class="header-anchor" href="#小程序" aria-label="Permalink to &quot;小程序&quot;">​</a></h3><ul><li>避免不当使用setData <ul><li>每次<code>setData</code>调用都是一次进程间通信过程，通信开销与<code>setDta</code>数据量正相关</li><li><code>setData</code>会引发视图层面内容更新，会阻塞用户交互</li><li>不要频繁调用<code>setData</code>与每次<code>setData</code>不要塞太多数量数据</li></ul></li><li>在列表渲染中合理使用key值</li><li>长列表渲染优化 <ul><li>虚拟列表</li><li>微信<a href="https://github.com/wechat-miniprogram/recycle-view" target="_blank" rel="noreferrer">recycle-view</a></li></ul></li><li>使用wxs直接操作视图数据，避免跨线程开销</li></ul>',14),r=[o];function c(n,s,d,h,u,p){return l(),e("div",null,r)}const f=i(t,[["render",c]]);export{m as __pageData,f as default};
