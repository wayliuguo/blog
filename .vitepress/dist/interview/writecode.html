<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、JavaScript基础 | well's blog</title>
    <meta name="description" content="well's blog">
    <link rel="preload stylesheet" href="/blog/assets/style.01456bfa.css" as="style">
    
    <script type="module" src="/blog/assets/app.99e7a8b1.js"></script>
    <link rel="preload" href="/blog/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/blog/assets/chunks/framework.9adb0f96.js">
    <link rel="modulepreload" href="/blog/assets/chunks/theme.0198b334.js">
    <link rel="modulepreload" href="/blog/assets/interview_writecode.md.47d3b640.lean.js">
    <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-ffdc1df7><!--[--><!--]--><!--[--><span tabindex="-1" data-v-9c8615dd></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-9c8615dd> Skip to content </a><!--]--><!----><header class="VPNav" data-v-ffdc1df7 data-v-5bdc5df3><div class="VPNavBar has-sidebar" data-v-5bdc5df3 data-v-4077a65e><div class="container" data-v-4077a65e><div class="title" data-v-4077a65e><div class="VPNavBarTitle has-sidebar" data-v-4077a65e data-v-6d57964e><a class="title" href="/blog/" data-v-6d57964e><!--[--><!--]--><!----><!--[-->well&#39;s blog<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-4077a65e><div class="curtain" data-v-4077a65e></div><div class="content-body" data-v-4077a65e><!--[--><!--]--><div class="VPNavBarSearch search" style="--vp-meta-key:&#39;Meta&#39;;" data-v-4077a65e><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-4077a65e data-v-f732b5d0><span id="main-nav-aria-label" class="visually-hidden" data-v-f732b5d0>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/article/project/normalizeConfig.html" tabindex="0" data-v-f732b5d0 data-v-7f10a92a><!--[-->文档<!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/node/nodeBasic.html" tabindex="0" data-v-f732b5d0 data-v-7f10a92a><!--[-->node<!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/blog/interview/css.html" tabindex="0" data-v-f732b5d0 data-v-7f10a92a><!--[-->不止于面试<!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/alg/array.html" tabindex="0" data-v-f732b5d0 data-v-7f10a92a><!--[-->算法<!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-4077a65e data-v-5e9f0637><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-5e9f0637 data-v-a99ed743 data-v-92d8f6fb><span class="check" data-v-92d8f6fb><span class="icon" data-v-92d8f6fb><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-a99ed743><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-a99ed743><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-4077a65e data-v-c8c2ae4b data-v-6afe904b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-6afe904b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-6afe904b><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-6afe904b><div class="VPMenu" data-v-6afe904b data-v-e42ed9b3><!----><!--[--><!--[--><!----><div class="group" data-v-c8c2ae4b><div class="item appearance" data-v-c8c2ae4b><p class="label" data-v-c8c2ae4b>Appearance</p><div class="appearance-action" data-v-c8c2ae4b><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-c8c2ae4b data-v-a99ed743 data-v-92d8f6fb><span class="check" data-v-92d8f6fb><span class="icon" data-v-92d8f6fb><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-a99ed743><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-a99ed743><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-4077a65e data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav reached-top" data-v-ffdc1df7 data-v-693d654a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-693d654a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-693d654a><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-693d654a>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-693d654a data-v-bd10e8af><button data-v-bd10e8af>Return to top</button><!----></div></div><aside class="VPSidebar" data-v-ffdc1df7 data-v-b04a928c><div class="curtain" data-v-b04a928c></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-b04a928c><span class="visually-hidden" id="sidebar-aria-label" data-v-b04a928c> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-b04a928c><section class="VPSidebarItem level-0 has-active" data-v-b04a928c data-v-66c2f55a><div class="item" role="button" tabindex="0" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><h2 class="text" data-v-66c2f55a>不止于面试</h2><!----></div><div class="items" data-v-66c2f55a><!--[--><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/css.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>css</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/html.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>html</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/javascript.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>javascript</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/typescript.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>typescript</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/vue.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>vue</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/codeconsole.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>代码输出</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link is-active has-active" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/writecode.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>手写代码</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/browser.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>浏览器原理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/network.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>计算机网络</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/networkinterview.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>计算机网络（面试）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/miniwechat.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>微信小程序</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/performance.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>性能优化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/softskill.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>软技能</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/interview/experience.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>面经</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-ffdc1df7 data-v-f0629f57><div class="VPDoc has-sidebar has-aside" data-v-f0629f57 data-v-a3c25e27><!--[--><!--]--><div class="container" data-v-a3c25e27><div class="aside" data-v-a3c25e27><div class="aside-curtain" data-v-a3c25e27></div><div class="aside-container" data-v-a3c25e27><div class="aside-content" data-v-a3c25e27><div class="VPDocAside" data-v-a3c25e27 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-cb998dce data-v-c834746b><div class="content" data-v-c834746b><div class="outline-marker" data-v-c834746b></div><div class="outline-title" data-v-c834746b>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-c834746b><span class="visually-hidden" id="doc-outline-aria-label" data-v-c834746b> Table of Contents for current page </span><ul class="root" data-v-c834746b data-v-89c8d7c6><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-a3c25e27><div class="content-container" data-v-a3c25e27><!--[--><!--]--><!----><main class="main" data-v-a3c25e27><div style="position:relative;" class="vp-doc _blog_interview_writecode" data-v-a3c25e27><div><h1 id="一、javascript基础" tabindex="-1">一、JavaScript基础 <a class="header-anchor" href="#一、javascript基础" aria-label="Permalink to &quot;一、JavaScript基础&quot;">​</a></h1><h2 id="_1-object-create" tabindex="-1">1. Object.create <a class="header-anchor" href="#_1-object-create" aria-label="Permalink to &quot;1. Object.create&quot;">​</a></h2><p>思路：新对象原型指向传入对象，从而继承传入对象的属性和方法</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Object.prototype.MyCreate = function (obj) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  function F() {}</span></span>
<span class="line"><span style="color:#A6ACCD;">  F.prototype = obj;</span></span>
<span class="line"><span style="color:#A6ACCD;">  return new F();</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const personPrototype = {</span></span>
<span class="line"><span style="color:#A6ACCD;">  greeting() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(`Hello, my name is ${this.name}.`);</span></span>
<span class="line"><span style="color:#A6ACCD;">  },</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">const john = Object.MyCreate(personPrototype);</span></span>
<span class="line"><span style="color:#A6ACCD;">john.name = &quot;John Doe&quot;;</span></span>
<span class="line"><span style="color:#A6ACCD;">john.greeting();</span></span></code></pre></div><h2 id="_2-new-操作符" tabindex="-1">2. new 操作符 <a class="header-anchor" href="#_2-new-操作符" aria-label="Permalink to &quot;2. new 操作符&quot;">​</a></h2><ul><li>通过<code>Object.create</code>创建一个空对象继承传入构造函数的原型。</li><li>指向构造函数，使其<code>this</code>指向新建的对象</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function objectFactory(constructor, ...args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 设置原型，将对象的原型设置为函数的 prototype 对象</span></span>
<span class="line"><span style="color:#A6ACCD;">  const obj = Object.create(constructor.prototype);</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 将 this 指向新建对象，并执行函数</span></span>
<span class="line"><span style="color:#A6ACCD;">  const result = constructor.apply(obj, args);</span></span>
<span class="line"><span style="color:#A6ACCD;">  return typeof result === &quot;object&quot; &amp;&amp; result !== null ? result : obj;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">function Person(name) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  this.name = name;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">const well = objectFactory(Person, &quot;well&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(well.name); // well</span></span></code></pre></div><h2 id="_3-instanceof" tabindex="-1">3. instanceof <a class="header-anchor" href="#_3-instanceof" aria-label="Permalink to &quot;3. instanceof&quot;">​</a></h2><ol><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function myInstanceof (left, right) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let proto = Object.getPrototypeOf(left)</span></span>
<span class="line"><span style="color:#A6ACCD;">    let constructor = right.prototype</span></span>
<span class="line"><span style="color:#A6ACCD;">    while (true) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (!proto) return false</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (proto === constructor) return true</span></span>
<span class="line"><span style="color:#A6ACCD;">        proto = Object.getPrototypeOf(proto)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log([] instanceof Array) // true</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(2 instanceof Number) // fasle</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(myInstanceof([], Array)) // true</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(myInstanceof(2, Number)) // true</span></span></code></pre></div><h2 id="_4-debounce" tabindex="-1">4. debounce <a class="header-anchor" href="#_4-debounce" aria-label="Permalink to &quot;4. debounce&quot;">​</a></h2><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function debounce(fn, wait) {</span></span>
<span class="line"><span style="color:#A6ACCD;">	let timer = null</span></span>
<span class="line"><span style="color:#A6ACCD;">	// 利用箭头函数this指向定义处</span></span>
<span class="line"><span style="color:#A6ACCD;">    return (...args) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    	if (timer) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            clearTimeout(timer)</span></span>
<span class="line"><span style="color:#A6ACCD;">            timer = null</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        timer = setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        	fn.apply(this, args)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }, wait)</span></span>
<span class="line"><span style="color:#A6ACCD;">   }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><h2 id="_5-throttle" tabindex="-1">5. throttle <a class="header-anchor" href="#_5-throttle" aria-label="Permalink to &quot;5. throttle&quot;">​</a></h2><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function throttle(fn, delay) {</span></span>
<span class="line"><span style="color:#A6ACCD;">	let startTime = Date.now()</span></span>
<span class="line"><span style="color:#A6ACCD;">	return (...args) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">		let nowTime = Date.now()</span></span>
<span class="line"><span style="color:#A6ACCD;">		if (nowTime - startTime &gt;= delay) {</span></span>
<span class="line"><span style="color:#A6ACCD;">			startTime = nowTime</span></span>
<span class="line"><span style="color:#A6ACCD;">			return fn.apply(this, args)</span></span>
<span class="line"><span style="color:#A6ACCD;">		}</span></span>
<span class="line"><span style="color:#A6ACCD;">	}</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><h2 id="_6-类型判断" tabindex="-1">6.类型判断 <a class="header-anchor" href="#_6-类型判断" aria-label="Permalink to &quot;6.类型判断&quot;">​</a></h2><p>主要是通过typeof 和 Object.prototype.toString.call()来判断，由于typeof null 也等于 &#39;object&#39;,所以才做了多一步的处理</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function getType (value) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 如果是null则返回</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (value === null) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        return value + &#39;&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 如果是数组、对象</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (typeof value === &#39;object&#39;) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // [object Array]</span></span>
<span class="line"><span style="color:#A6ACCD;">        let valueClass = Object.prototype.toString.call(value)</span></span>
<span class="line"><span style="color:#A6ACCD;">        let type = valueClass.split(&#39; &#39;)[1].split(&#39;&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">        type.pop()</span></span>
<span class="line"><span style="color:#A6ACCD;">        // [&#39;A&#39;, &#39;r&#39;, &#39;r&#39;, &#39;a&#39;, &#39;y&#39;]</span></span>
<span class="line"><span style="color:#A6ACCD;">        return type.join(&#39;&#39;).toLowerCase()</span></span>
<span class="line"><span style="color:#A6ACCD;">    } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">        return typeof value</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(getType([])) // array</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(getType(2)) // number</span></span></code></pre></div><h2 id="_7-call" tabindex="-1">7.call <a class="header-anchor" href="#_7-call" aria-label="Permalink to &quot;7.call&quot;">​</a></h2><p>核心思想：把调用方法作为contex的属性去执行，并把得到的结果返回</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Function.prototype.MyCall = function (context, ...args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  context = context || window;</span></span>
<span class="line"><span style="color:#A6ACCD;">  context.fn = this;</span></span>
<span class="line"><span style="color:#A6ACCD;">  const result = context.fn(...args);</span></span>
<span class="line"><span style="color:#A6ACCD;">  delete context.fn;</span></span>
<span class="line"><span style="color:#A6ACCD;">  return result;</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const Person = {</span></span>
<span class="line"><span style="color:#A6ACCD;">  name: &quot;well&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">function sayName(age) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return `name:${this.name},age:${age}`;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(sayName.MyCall(Person, 18)); // name:well,age:18</span></span></code></pre></div><h2 id="_8-apply" tabindex="-1">8.apply <a class="header-anchor" href="#_8-apply" aria-label="Permalink to &quot;8.apply&quot;">​</a></h2><p>核心思想：把调用方法作为contex的属性去执行，并把得到的结果返回。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Function.prototype.MyApply = function (context, ...args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  context = context || window;</span></span>
<span class="line"><span style="color:#A6ACCD;">  context.fn = this;</span></span>
<span class="line"><span style="color:#A6ACCD;">  const result = context.fn(...args);</span></span>
<span class="line"><span style="color:#A6ACCD;">  delete context.fn;</span></span>
<span class="line"><span style="color:#A6ACCD;">  return result;</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const Person = {</span></span>
<span class="line"><span style="color:#A6ACCD;">  name: &quot;well&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">function sayName(age) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return `name:${this.name},age:${age}`;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(sayName.MyApply(Person, [18]));</span></span></code></pre></div><h2 id="_9-bind" tabindex="-1">9.bind <a class="header-anchor" href="#_9-bind" aria-label="Permalink to &quot;9.bind&quot;">​</a></h2><p>bind 函数的实现步骤：</p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Function.prototype.myBind = function (context, ...args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  context = context || window;</span></span>
<span class="line"><span style="color:#A6ACCD;">  const fn = this;</span></span>
<span class="line"><span style="color:#A6ACCD;">  return function Fn() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 根据调用方式，传入不同绑定值</span></span>
<span class="line"><span style="color:#A6ACCD;">    return fn.apply(</span></span>
<span class="line"><span style="color:#A6ACCD;">      this instanceof Fn ? this : context,</span></span>
<span class="line"><span style="color:#A6ACCD;">      args.concat(...arguments)</span></span>
<span class="line"><span style="color:#A6ACCD;">    );</span></span>
<span class="line"><span style="color:#A6ACCD;">  };</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const foo = {</span></span>
<span class="line"><span style="color:#A6ACCD;">  a: 1,</span></span>
<span class="line"><span style="color:#A6ACCD;">  log(x, y) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(this.a, x, y);</span></span>
<span class="line"><span style="color:#A6ACCD;">  },</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">const obj = {</span></span>
<span class="line"><span style="color:#A6ACCD;">  a: 10,</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">foo.log.myBind(obj, 5, 6)(); // 10, 5, 6</span></span></code></pre></div><h2 id="_10-实现浅拷贝" tabindex="-1">10. 实现浅拷贝 <a class="header-anchor" href="#_10-实现浅拷贝" aria-label="Permalink to &quot;10. 实现浅拷贝&quot;">​</a></h2><p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</p><ul><li>Object.assign()</li><li>扩展运算符</li><li>数组方法实现数组浅拷贝</li></ul><h3 id="_10-1-object-assign" tabindex="-1">10.1 Object.assign() <a class="header-anchor" href="#_10-1-object-assign" aria-label="Permalink to &quot;10.1 Object.assign()&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">let target = {a: 1};</span></span>
<span class="line"><span style="color:#A6ACCD;">let object2 = {b: 2};</span></span>
<span class="line"><span style="color:#A6ACCD;">let object3 = {c: 3};</span></span>
<span class="line"><span style="color:#A6ACCD;">Object.assign(target,object2,object3);  </span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(target);  // {a: 1, b: 2, c: 3}</span></span></code></pre></div><h3 id="_10-2-扩展运算符" tabindex="-1">10.2 扩展运算符 <a class="header-anchor" href="#_10-2-扩展运算符" aria-label="Permalink to &quot;10.2 扩展运算符&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">let obj4 = {a:1,b:{c:1}}</span></span>
<span class="line"><span style="color:#A6ACCD;">let obj5 = {...obj4} // { a: 1, b: { c: 1 } }</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(obj5)</span></span></code></pre></div><h3 id="_10-3-数组方法实现数组浅拷贝" tabindex="-1">10.3 数组方法实现数组浅拷贝 <a class="header-anchor" href="#_10-3-数组方法实现数组浅拷贝" aria-label="Permalink to &quot;10.3 数组方法实现数组浅拷贝&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// Array.prototype.slice</span></span>
<span class="line"><span style="color:#A6ACCD;">let arr = [1,2,3,4];</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(arr.slice()); // [1,2,3,4]</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(arr.slice() === arr); //false</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// Array.prototype.concat</span></span>
<span class="line"><span style="color:#A6ACCD;">let arr2 = [1,2,3,4];</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(arr2.concat()); // [1,2,3,4]</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(arr2.concat() === arr); //false</span></span></code></pre></div><h3 id="_10-4-浅拷贝的实现" tabindex="-1">10.4 浅拷贝的实现 <a class="header-anchor" href="#_10-4-浅拷贝的实现" aria-label="Permalink to &quot;10.4 浅拷贝的实现&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function shallowCopy(object) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 只拷贝对象</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (!object || typeof object !== &#39;object&#39;) return</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 根据object 的类型判断新建的是数组还是对象</span></span>
<span class="line"><span style="color:#A6ACCD;">    let newObject = Array.isArray(object) ? [] : {}</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 遍历object，判断是object的属性才拷贝</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let key in object) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (object.hasOwnProperty(key)) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            newObject[key] = object[key]</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return newObject</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">const myObject = [1,2,3,4,5]</span></span>
<span class="line"><span style="color:#A6ACCD;">const newShallowObject = shallowCopy(myObject)</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(newShallowObject) // [ 1, 2, 3, 4, 5 ]</span></span></code></pre></div><h2 id="_11-实现深拷贝" tabindex="-1">11. 实现深拷贝 <a class="header-anchor" href="#_11-实现深拷贝" aria-label="Permalink to &quot;11. 实现深拷贝&quot;">​</a></h2><p>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p><ul><li>JSON.stringify</li><li>lodash的_.cloneDeep</li><li>手动实现深拷贝函数</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const obj1 = {</span></span>
<span class="line"><span style="color:#A6ACCD;">    a: 1,</span></span>
<span class="line"><span style="color:#A6ACCD;">    b: { f: { g: 1 } },</span></span>
<span class="line"><span style="color:#A6ACCD;">    c: [1, 2, 3]</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">// JSON.stringfy</span></span>
<span class="line"><span style="color:#A6ACCD;">const obj2 = JSON.parse(JSON.stringify(obj1))</span></span>
<span class="line"><span style="color:#A6ACCD;">obj2.b.e =2</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(obj1) // { a: 1, b: { f: { g: 1 } }, c: [ 1, 2, 3 ] }</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(obj2) // { a: 1, b: { f: { g: 1 }, e: 2 }, c: [ 1, 2, 3 ] }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 深拷贝的实现</span></span>
<span class="line"><span style="color:#A6ACCD;">function deepCopy (object) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 只拷贝对象</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (!object || typeof object !== &#39;object&#39;) return</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 根据object 的类型判断新建的是数组还是对象</span></span>
<span class="line"><span style="color:#A6ACCD;">    let newObject = Array.isArray(object) ? [] : {}</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 遍历 object</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let key in object) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (object.hasOwnProperty(key)) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            newObject[key] = typeof object[key] === &#39;object&#39; ? deepCopy(object[key]) : object[key]</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return newObject</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">const obj3 = deepCopy(obj1)</span></span>
<span class="line"><span style="color:#A6ACCD;">obj3.b.f.g = 5</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(obj1) // { a: 1, b: { f: { g: 1 } }, c: [ 1, 2, 3 ] }</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(obj3) // { a: 1, b: { f: { g: 5 } }, c: [ 1, 2, 3 ] }</span></span></code></pre></div><h2 id="_12-实现-sleep-函数" tabindex="-1">12.实现 sleep 函数 <a class="header-anchor" href="#_12-实现-sleep-函数" aria-label="Permalink to &quot;12.实现 sleep 函数&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function sleep (wait) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return new Promise(resolve =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        setTimeout(resolve, wait)</span></span>
<span class="line"><span style="color:#A6ACCD;">    })</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">const curTime = Date.now()</span></span>
<span class="line"><span style="color:#A6ACCD;">sleep(3000).then(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(Date.now() - curTime) // 3000</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span></code></pre></div><h2 id="_13-实现-object-assign" tabindex="-1">13. 实现 Object.assign <a class="header-anchor" href="#_13-实现-object-assign" aria-label="Permalink to &quot;13. 实现 Object.assign&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Object.myAssign = function (target, ...source) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (target === null) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        throw new TypeError(&#39;error&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    let ret = Object(target)</span></span>
<span class="line"><span style="color:#A6ACCD;">    source.forEach(obj =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (obj !== null) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            for (let key in obj) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                if (obj.hasOwnProperty(key)) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                    ret[key] = obj[key]</span></span>
<span class="line"><span style="color:#A6ACCD;">                }</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    })</span></span>
<span class="line"><span style="color:#A6ACCD;">    return ret</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">let target = {a: 1}</span></span>
<span class="line"><span style="color:#A6ACCD;">let object2 = {b: 2}</span></span>
<span class="line"><span style="color:#A6ACCD;">let object3 = {c: 3}</span></span>
<span class="line"><span style="color:#A6ACCD;">Object.myAssign(target,object2,object3)</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(target);  // {a: 1, b: 2, c: 3}</span></span></code></pre></div><h2 id="_14-手写-promise" tabindex="-1">14.手写 Promise <a class="header-anchor" href="#_14-手写-promise" aria-label="Permalink to &quot;14.手写 Promise&quot;">​</a></h2><h3 id="_14-1声明-promise-类-then-的基础构建" tabindex="-1">14.1声明 Promise 类 &amp; then 的基础构建 <a class="header-anchor" href="#_14-1声明-promise-类-then-的基础构建" aria-label="Permalink to &quot;14.1声明 Promise 类 &amp; then 的基础构建&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const PENDING = &#39;pengding&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">const FULFILLED = &#39;fulfilled&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">const REJECTED = &#39;rejected&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class myPromise {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (executor) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 保存 promise 的状态</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.state = PENDING</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 成功结果</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.value = undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 失败结果</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.reason = undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">        // resolve 方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        const resolve = (value) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (this.state = PENDING) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.state = FULFILLED</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.value = value</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        const reject = (reason) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (this.state = PENDING) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.state = REJECTED</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.reason = reason</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        try {</span></span>
<span class="line"><span style="color:#A6ACCD;">            executor(resolve, reject)</span></span>
<span class="line"><span style="color:#A6ACCD;">        } catch (e) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            reject(e)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    // then 方法</span></span>
<span class="line"><span style="color:#A6ACCD;">    then (onFulfilled, onRejected) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 如果状态是 fulfilled，则执行then传入的 onFulfilled 函数</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (this.state === FULFILLED) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            typeof onFulfilled === &#39;function&#39; &amp;&amp; onFulfilled(this.value)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 如果状态是 fulfilled，则执行then传入的 onRejected 函数</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (this.state === REJECTED) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            typeof onRejected === &#39;function&#39; &amp;&amp; onRejected(this.reason)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const promise = new myPromise ((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    resolve(1)</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(promise) // myPromise { state: &#39;fulfilled&#39;, value: 1, reason: undefined }</span></span>
<span class="line"><span style="color:#A6ACCD;">promise.then((res) =&gt; console.log(res)) // 1</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 漏洞</span></span>
<span class="line"><span style="color:#A6ACCD;">const promiseError = new myPromise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(&#39;执行&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        reject(3)</span></span>
<span class="line"><span style="color:#A6ACCD;">    })</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(promiseError) // myPromise { state: &#39;pengding&#39;, value: undefined, reason: undefined } </span></span>
<span class="line"><span style="color:#A6ACCD;">promiseError.then(res =&gt; console.log(res), err =&gt; console.log(err))</span></span></code></pre></div><ul><li>resolve: 把state 变为 fulfilled， 改变value</li><li>reject：把state 变为 rejected，改变reason</li><li>由于setTimeout是宏任务，放入宏任务队列，执行了下面的then，由于还没有resolve或者reject，所以状态还是pending。</li></ul><h3 id="_14-2-then-进一步优化" tabindex="-1">14.2 then 进一步优化 <a class="header-anchor" href="#_14-2-then-进一步优化" aria-label="Permalink to &quot;14.2 then 进一步优化&quot;">​</a></h3><p><strong>参考发布订阅模式，在执行then的时候，如果当时还是 pending 状态，就把回调函数寄存到一个数组中，当状态发生改变时，去数组中取出回调函数。</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class myPromise {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (executor) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    	...</span></span>
<span class="line"><span style="color:#A6ACCD;">    	// 成功的回调</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.onFulfilled = []</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 失败的回调</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.onRejected = []</span></span>
<span class="line"><span style="color:#A6ACCD;">        // resolve 方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        const resolve = (value) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (this.state = PENDING) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.state = FULFILLED</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.value = value</span></span>
<span class="line"><span style="color:#A6ACCD;">                // 执行成功的回调</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.onFulfilled.forEach(fn =&gt; fn(value))</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        const reject = (reason) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (this.state = PENDING) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.state = REJECTED</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.reason = reason</span></span>
<span class="line"><span style="color:#A6ACCD;">                // 执行失败的回调</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.onRejected.forEach(fn =&gt; fn(reason))</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    then (onFulfilled, onRejected) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    	...</span></span>
<span class="line"><span style="color:#A6ACCD;">    	// 如果状态是 pending，不是马上执行回调函数，而是将其存储起来</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (this.state === PENDING) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            typeof onFulfilled === &#39;function&#39; &amp;&amp; this.onFulfilled.push(onFulfilled)</span></span>
<span class="line"><span style="color:#A6ACCD;">            typeof onRejected === &#39;function&#39; &amp;&amp; this.onRejected.push(onRejected)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const promise = new myPromise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        resolve(1)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }, 1000)</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">promise.then(res =&gt; console.log(res)) // 1</span></span>
<span class="line"><span style="color:#A6ACCD;">promise.then(res =&gt; console.log(res)) // 1</span></span></code></pre></div><p><strong>原生的promise.then()中的代码是异步执行的，所以需要进一步优化，否则出现下面代码执行顺序</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const promise = new myPromise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    resolve(1)</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">promise.then(res =&gt; console.log(res)) // 1</span></span>
<span class="line"><span style="color:#A6ACCD;">promise.then(res =&gt; console.log(res)) // 1</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(2)</span></span></code></pre></div><ul><li>1</li><li>1</li><li>2</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">then (onFulfilled, onRejected) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if(typeof onFulfilled !== &#39;function&#39;) onFulfilled = () =&gt; {}</span></span>
<span class="line"><span style="color:#A6ACCD;">        if(typeof onRejected !== &#39;function&#39;) onRejected = () =&gt; {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        // 如果状态是 pending，不是马上执行回调函数，而是将其存储起来</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (this.state === PENDING) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            this.onFulfilled.push(</span></span>
<span class="line"><span style="color:#A6ACCD;">                () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">                    setTimeout(() =&gt; onFulfilled(this.value))</span></span>
<span class="line"><span style="color:#A6ACCD;">                }</span></span>
<span class="line"><span style="color:#A6ACCD;">            )</span></span>
<span class="line"><span style="color:#A6ACCD;">            this.onRejected.push(</span></span>
<span class="line"><span style="color:#A6ACCD;">                () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">                    setTimeout(() =&gt; onRejected(this.reason))</span></span>
<span class="line"><span style="color:#A6ACCD;">                }</span></span>
<span class="line"><span style="color:#A6ACCD;">            )</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 如果状态是 fulfilled，则执行then传入的 onFulfilled 函数</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (this.state === FULFILLED) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            setTimeout(() =&gt; onFulfilled(this.value))</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 如果状态是 fulfilled，则执行then传入的 onRejected 函数</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (this.state === REJECTED) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            setTimeout(() =&gt; onRejected(this.reason))</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span></code></pre></div><h3 id="_14-3-链式调用" tabindex="-1">14.3 链式调用 <a class="header-anchor" href="#_14-3-链式调用" aria-label="Permalink to &quot;14.3 链式调用&quot;">​</a></h3><ul><li>promise 是支持链式调用的，就是 .then() 之后还可以继续 .then()</li><li>所以 then 返回的应该还是一个 promise 对象，并且在这个返回的promise 中就调用了 resolve 或者 reject方法，改变了state，这样的话下一个then 的回调就可以获取到 value 或者 reason</li><li>由于promise 可以穿透，即前面的then不传入回调，后面的then的回调依然能接收到 value 或者 reason，所以 then 的实现中，如果没有传入回调函数，则定义一下回调函数即可</li><li>如果在 then 中发生了错误，则返回的promise对象的状态应该是调用了 reject 方法，把 state 改成了 rejected 状态的。</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">then (onFulfilled, onRejected) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if(typeof onFulfilled !== &#39;function&#39;) onFulfilled = () =&gt; {}</span></span>
<span class="line"><span style="color:#A6ACCD;">        if(typeof onRejected !== &#39;function&#39;) onRejected = () =&gt; {}</span></span>
<span class="line"><span style="color:#A6ACCD;">        return new myPromise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            // 如果状态是 pending，不是马上执行回调函数，而是将其存储起来</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (this.state === PENDING) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.onFulfilled.push(</span></span>
<span class="line"><span style="color:#A6ACCD;">                    () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">                        setTimeout(() =&gt; resolve(onFulfilled(this.value)))</span></span>
<span class="line"><span style="color:#A6ACCD;">                    }</span></span>
<span class="line"><span style="color:#A6ACCD;">                )</span></span>
<span class="line"><span style="color:#A6ACCD;">                this.onRejected.push(</span></span>
<span class="line"><span style="color:#A6ACCD;">                    () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">                        setTimeout(() =&gt; resolve(onRejected(this.reason)))</span></span>
<span class="line"><span style="color:#A6ACCD;">                    }</span></span>
<span class="line"><span style="color:#A6ACCD;">                )</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">            // 如果状态是 fulfilled，则执行then传入的 onFulfilled 函数</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (this.state === FULFILLED) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                setTimeout(() =&gt; resolve(onFulfilled(this.value)))</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">            // 如果状态是 fulfilled，则执行then传入的 onRejected 函数</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (this.state === REJECTED) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                setTimeout(() =&gt; resolve(onRejected(this.reason)))</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        })</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const promise = new myPromise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    resolve(1)</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">promise</span></span>
<span class="line"><span style="color:#A6ACCD;">    .then(res =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(res)</span></span>
<span class="line"><span style="color:#A6ACCD;">        return res</span></span>
<span class="line"><span style="color:#A6ACCD;">    })</span></span>
<span class="line"><span style="color:#A6ACCD;">    .then(res =&gt; console.log(res))</span></span>
<span class="line"><span style="color:#A6ACCD;">// 输出： 1 1</span></span></code></pre></div><p><strong>处理then 穿透</strong></p><p>原生：promise.then().then(res =&gt; console.log(res))中依然可以拿到前面传递过来的参数，这里就是then的穿透。</p><p>实现 then 的穿透也非常简单，更改一下 onFulfilled 和 onRejected 不是函数的情况的处理即可：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">then (onFulfilled, onRejected) {</span></span>
<span class="line"><span style="color:#A6ACCD;">	if(typeof onFulfilled !== &#39;function&#39;) onFulfilled = value =&gt; value</span></span>
<span class="line"><span style="color:#A6ACCD;">    if(typeof onRejected !== &#39;function&#39;) onRejected = reason =&gt; {throw reason}</span></span>
<span class="line"><span style="color:#A6ACCD;">    ...</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p><strong>异常处理</strong></p><p>如果在then中出现了错误，需要返回的下一个promise 的 state 变为 rejected，所以需要添加异常处理</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">try {</span></span>
<span class="line"><span style="color:#A6ACCD;">	resolve(onFulfilled(this.value))</span></span>
<span class="line"><span style="color:#A6ACCD;">} catch(e) {</span></span>
<span class="line"><span style="color:#A6ACCD;">	reject(e)</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><h3 id="_14-4-封装-resolvepromise-来处理-promise" tabindex="-1">14-4 封装 resolvePromise 来处理 promise <a class="header-anchor" href="#_14-4-封装-resolvepromise-来处理-promise" aria-label="Permalink to &quot;14-4 封装 resolvePromise 来处理 promise&quot;">​</a></h3><p>在前面我们已经基本完成了 then，而一些特殊情况依旧会造成问题：</p><ol><li><p>循环引用自身</p><p>在原生Promise中，如果一个promise的onResolved返回了自身，比如这样</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const promise =  new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  resolve()</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">const p = promise.then(() =&gt; p)</span></span>
<span class="line"><span style="color:#A6ACCD;">// Uncaught (in promise) TypeError: A promise cannot be resolved with itself.</span></span></code></pre></div></li><li><p>onResolved 返回了一个 promise 对象</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  resolve()</span></span>
<span class="line"><span style="color:#A6ACCD;">}).then(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">	return new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    resolve(&#39;hi&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">  })</span></span>
<span class="line"><span style="color:#A6ACCD;">}).then(res =&gt; console.log(res))</span></span></code></pre></div><p>在原生 Promise 中，当 onResolved 返回了一个 promise 对象时，会将其 resolve 或 reject 的值传递到下一个 then, 所以打印结果是 ‘hi’</p></li><li><p>onResolved 返回了一个嵌套的 promise 对象</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  resolve()</span></span>
<span class="line"><span style="color:#A6ACCD;">}).then(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    resolve(new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">      resolve(&#39;hi&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }))</span></span>
<span class="line"><span style="color:#A6ACCD;">  })</span></span>
<span class="line"><span style="color:#A6ACCD;">}).then(res =&gt; console.log(res)) // hi</span></span></code></pre></div></li></ol><h1 id="二、数据处理" tabindex="-1">二、数据处理 <a class="header-anchor" href="#二、数据处理" aria-label="Permalink to &quot;二、数据处理&quot;">​</a></h1><h2 id="_15-实现日期格式化函数" tabindex="-1">15.实现日期格式化函数 <a class="header-anchor" href="#_15-实现日期格式化函数" aria-label="Permalink to &quot;15.实现日期格式化函数&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const dateFormat = function (dateInput, format) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    const day = dateInput.getDate()</span></span>
<span class="line"><span style="color:#A6ACCD;">    const month = dateInput.getMonth() + 1</span></span>
<span class="line"><span style="color:#A6ACCD;">    const year = dateInput.getFullYear()</span></span>
<span class="line"><span style="color:#A6ACCD;">    format = format.replace(/yyyy/, year)</span></span>
<span class="line"><span style="color:#A6ACCD;">    format = format.replace(/MM/, month)</span></span>
<span class="line"><span style="color:#A6ACCD;">    format = format.replace(/dd/, day)</span></span>
<span class="line"><span style="color:#A6ACCD;">    return format</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(dateFormat(new Date(&#39;2020-12-01&#39;), &#39;yyyy/MM/dd&#39;)) // 2020/12/01</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(dateFormat(new Date(&#39;2020-04-01&#39;), &#39;yyyy/MM/dd&#39;)) // 2020/04/01</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(dateFormat(new Date(&#39;2020-04-01&#39;), &#39;yyyy年MM月dd日&#39;)) // 2020年04月01日</span></span></code></pre></div><h2 id="_16-实现数组的乱序输出" tabindex="-1">16. 实现数组的乱序输出 <a class="header-anchor" href="#_16-实现数组的乱序输出" aria-label="Permalink to &quot;16. 实现数组的乱序输出&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const arr = [1,2,3,4,5,6,7,8,9,10]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">let length = arr.length</span></span>
<span class="line"><span style="color:#A6ACCD;">let randomIndex</span></span>
<span class="line"><span style="color:#A6ACCD;">while (length) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    randomIndex = Math.floor(Math.random() * length)</span></span>
<span class="line"><span style="color:#A6ACCD;">    length--</span></span>
<span class="line"><span style="color:#A6ACCD;">    [arr[length], arr[randomIndex]] = [arr[randomIndex], arr[length]]</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(arr)</span></span></code></pre></div><h2 id="_17-实现数组元素的求和" tabindex="-1">17.实现数组元素的求和 <a class="header-anchor" href="#_17-实现数组元素的求和" aria-label="Permalink to &quot;17.实现数组元素的求和&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">let arr = [1,2,3,4,5,6,7,8,9,10]</span></span>
<span class="line"><span style="color:#A6ACCD;">// reduce</span></span>
<span class="line"><span style="color:#A6ACCD;">let sum = arr.reduce((total, i) =&gt; total += i, 0)</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(sum) // 5</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 递归</span></span>
<span class="line"><span style="color:#A6ACCD;">function add (arr) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (arr.length === 1) return arr[0]</span></span>
<span class="line"><span style="color:#A6ACCD;">    return arr[0] + add(arr.slice(1)) </span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(add(arr)) // 5</span></span></code></pre></div><h2 id="_18-数组扁平化" tabindex="-1">18.数组扁平化 <a class="header-anchor" href="#_18-数组扁平化" aria-label="Permalink to &quot;18.数组扁平化&quot;">​</a></h2><ul><li>递归实现</li><li>迭代实现</li><li>扩展运算符实现</li><li>split 和 toString</li><li>ES6 flat</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">let arr = [1, [2, [3, 4, 5]]]</span></span>
<span class="line"><span style="color:#A6ACCD;">// 递归实现</span></span>
<span class="line"><span style="color:#A6ACCD;">function flatten (arr) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let result = []</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;arr.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (Array.isArray(arr[i])) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            result = result.concat(flatten(arr[i]))</span></span>
<span class="line"><span style="color:#A6ACCD;">        } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">            result.push(arr[i])</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return result</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(flatten(arr)) // [ 1, 2, 3, 4, 5 ]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 迭代实现</span></span>
<span class="line"><span style="color:#A6ACCD;">function flattenReduce (arr) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return arr.reduce((previousValue, currentValue) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        return previousValue.concat(Array.isArray(currentValue) ? flattenReduce(currentValue) : currentValue)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }, [])</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(flattenReduce(arr)) // [ 1, 2, 3, 4, 5 ]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 扩展运算符实现</span></span>
<span class="line"><span style="color:#A6ACCD;">function flattenExtension (arr) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    while(arr.some(item =&gt; Array.isArray(item))) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        arr = [].concat(...arr)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return arr</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(flattenExtension(arr)) // [ 1, 2, 3, 4, 5 ]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// split 和 toString </span></span>
<span class="line"><span style="color:#A6ACCD;">function flattenByString (arr) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return arr.toString().split(&quot;,&quot;)</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(flattenByString(arr)) // [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39; ]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// ES6 flat</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(arr.flat(Infinity)) // [ 1, 2, 3, 4, 5 ]</span></span></code></pre></div><h2 id="_19-数组去重" tabindex="-1">19. 数组去重 <a class="header-anchor" href="#_19-数组去重" aria-label="Permalink to &quot;19. 数组去重&quot;">​</a></h2><ul><li>set</li><li>map</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// Array.from(new Set(arr))</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(Array.from(new Set(array))) // [ 1, 2, 3, 5, 9, 8 ]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// map</span></span>
<span class="line"><span style="color:#A6ACCD;">function uniqueArray (arr) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let map = new Map()</span></span>
<span class="line"><span style="color:#A6ACCD;">    let res = []</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;arr.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (!map.has(arr[i])) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            map.set(arr[i], 1)</span></span>
<span class="line"><span style="color:#A6ACCD;">            res.push(arr[i])</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return res</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(uniqueArray(array)) // [ 1, 2, 3, 5, 9, 8 ]</span></span></code></pre></div><h2 id="_20-flat-实现" tabindex="-1">20. flat 实现 <a class="header-anchor" href="#_20-flat-实现" aria-label="Permalink to &quot;20. flat 实现&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function _flat (arr, depth) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (!Array.isArray(arr) || depth &lt;= 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        return arr</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return arr.reduce((previousVal, currentVal) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (Array.isArray(currentVal)) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            return previousVal.concat(_flat(currentVal, depth - 1))</span></span>
<span class="line"><span style="color:#A6ACCD;">        } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">            return previousVal.concat(currentVal)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }, [])</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">let arr = [1, [2, [3, 4, 5]]]</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(_flat(arr, 1)) // [ 1, 2, [ 3, 4, 5 ] ]</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(arr.flat(1)) // [ 1, 2, [ 3, 4, 5 ] ]</span></span></code></pre></div><h2 id="_21-push-实现" tabindex="-1">21. push 实现 <a class="header-anchor" href="#_21-push-实现" aria-label="Permalink to &quot;21. push 实现&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Array.prototype.myPush = function (...args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;args.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this[this.length] = args[i]</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return this.length</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">const arr = [1, 2, 3]</span></span>
<span class="line"><span style="color:#A6ACCD;">const ret = arr.push(4, 5, 6)</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(ret) // 6</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(arr) // [ 1, 2, 3, 4, 5, 6 ]</span></span></code></pre></div><h2 id="_22-filter-实现" tabindex="-1">22. filter 实现 <a class="header-anchor" href="#_22-filter-实现" aria-label="Permalink to &quot;22. filter 实现&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Array.prototype.myFilter = function (fn) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (typeof fn !== &#39;function&#39;) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        throw TypeError(&#39;参数必须是一个函数&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    let res = []</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;this.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        fn(this[i]) &amp;&amp; res.push(this[i])</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return res</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const arr = [1, 2, 3, 4, 5, 6]</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(arr.myFilter(item =&gt; item&gt;3)) // [ 4, 5, 6 ]</span></span></code></pre></div><h2 id="_23-map-实现" tabindex="-1">23. map 实现 <a class="header-anchor" href="#_23-map-实现" aria-label="Permalink to &quot;23. map 实现&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Array.prototype.myMap = function (fn) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (typeof fn !== &#39;function&#39;) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        throw TypeError(&#39;参数必须是一个函数&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    const res = []</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;this.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        res.push(fn(this[i]))</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return res</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const arr = [1, 2, 3, 4, 5, 6]</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(arr.myMap(item =&gt; item * item)) // [ 1, 4, 9, 16, 25, 36 ]</span></span></code></pre></div><h2 id="_24-repeat-实现" tabindex="-1">24.repeat 实现 <a class="header-anchor" href="#_24-repeat-实现" aria-label="Permalink to &quot;24.repeat 实现&quot;">​</a></h2><ul><li>冒泡实现</li><li>迭代实现</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function repeat(s, n) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (n &gt; 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        return s + repeat(s, --n)</span></span>
<span class="line"><span style="color:#A6ACCD;">    } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">        return &#39;&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">function repeatReduce (s, n) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    while (n &gt; 1) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        s += s</span></span>
<span class="line"><span style="color:#A6ACCD;">        n--</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return s</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(repeat(&#39;abc&#39;, 2)) // abcabc</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(repeatReduce(&#39;abc&#39;, 2)) // abcabc</span></span></code></pre></div><h2 id="_25-柯里化-参数长度不确定" tabindex="-1">25.柯里化-参数长度不确定 <a class="header-anchor" href="#_25-柯里化-参数长度不确定" aria-label="Permalink to &quot;25.柯里化-参数长度不确定&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 参数长度不固定</span></span>
<span class="line"><span style="color:#A6ACCD;">function currying (fn) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let args = []</span></span>
<span class="line"><span style="color:#A6ACCD;">    return function temp (...newArgs) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (newArgs.length) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            args = [</span></span>
<span class="line"><span style="color:#A6ACCD;">                ...args,</span></span>
<span class="line"><span style="color:#A6ACCD;">                ...newArgs</span></span>
<span class="line"><span style="color:#A6ACCD;">            ]</span></span>
<span class="line"><span style="color:#A6ACCD;">            return temp</span></span>
<span class="line"><span style="color:#A6ACCD;">        } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">            let val = fn.apply(this, args)</span></span>
<span class="line"><span style="color:#A6ACCD;">            args = [] //保证再次调用时清空</span></span>
<span class="line"><span style="color:#A6ACCD;">            return val</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">function add (...args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    //求和</span></span>
<span class="line"><span style="color:#A6ACCD;">    return args.reduce((a, b) =&gt; a + b)</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">function getSum (a,b,c) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return a+b+c</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">let addCurry = currying(add)</span></span>
<span class="line"><span style="color:#A6ACCD;">let getSumCurry = currying(getSum)</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(addCurry(1)(2)(3)(4, 5)())  //15</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(addCurry(1)(2)(3, 4, 5)())  //15</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(addCurry(1)(2, 3, 4, 5)())  //15</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(getSumCurry(1,2,3)()) // 6</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(getSumCurry(1)(2)(3)()) // 6</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(getSumCurry(1,2)(3)()) // 6</span></span></code></pre></div><h2 id="_26-柯里化-参数长度确定" tabindex="-1">26.柯里化-参数长度确定 <a class="header-anchor" href="#_26-柯里化-参数长度确定" aria-label="Permalink to &quot;26.柯里化-参数长度确定&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 参数长度固定</span></span>
<span class="line"><span style="color:#A6ACCD;">function curry (func) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return function curriedFn(...args) { // 使用剩余参数接收实参</span></span>
<span class="line"><span style="color:#A6ACCD;">        //  如果实参小于形参，递归执行(func.length: 传入函数的参数长度)</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (args.length &lt; func.length) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            return function () {</span></span>
<span class="line"><span style="color:#A6ACCD;">                // argument 是再次调用的实参，需转换为数组然后拼接之前转为参数</span></span>
<span class="line"><span style="color:#A6ACCD;">                return curriedFn(...[...args, ...arguments])</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 如果实参等于形参直接执行</span></span>
<span class="line"><span style="color:#A6ACCD;">        return func(...args)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><h2 id="_27-函数组合" tabindex="-1">27. 函数组合 <a class="header-anchor" href="#_27-函数组合" aria-label="Permalink to &quot;27. 函数组合&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function composeRight(...args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return function(value) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        let res = value</span></span>
<span class="line"><span style="color:#A6ACCD;">        for (let i=args.length-1; i&gt;=0; i--) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            res = args[i](res)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        return res</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">function composeRightReduce(...args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return function(value) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // reduce:对数组中的每一个元素执行提供的函数，并汇总成单个结果</span></span>
<span class="line"><span style="color:#A6ACCD;">        return args.reverse().reduce(function(acc,fn) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            return fn(acc)</span></span>
<span class="line"><span style="color:#A6ACCD;">        },value) // 把value作为acc的初始值</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const reverse = arr =&gt; arr.reverse()</span></span>
<span class="line"><span style="color:#A6ACCD;">const first = arr =&gt; arr[0]</span></span>
<span class="line"><span style="color:#A6ACCD;">const toUpper = s =&gt; s.toUpperCase()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const f = composeRight(toUpper,first,reverse)</span></span>
<span class="line"><span style="color:#A6ACCD;">const fReduce = composeRightReduce(toUpper,first,reverse)</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(f([&#39;one&#39;,&#39;two&#39;,&#39;three&#39;])) // THREE</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(fReduce([&#39;one&#39;,&#39;two&#39;,&#39;three&#39;])) // THREE</span></span></code></pre></div><h1 id="三、场景应用" tabindex="-1">三、场景应用 <a class="header-anchor" href="#三、场景应用" aria-label="Permalink to &quot;三、场景应用&quot;">​</a></h1><h2 id="_28-红蓝绿循环打印" tabindex="-1">28.红蓝绿循环打印 <a class="header-anchor" href="#_28-红蓝绿循环打印" aria-label="Permalink to &quot;28.红蓝绿循环打印&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function red() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(&#39;red&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">function green() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(&#39;green&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">function yellow() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(&#39;yellow&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">// 回调函数实现</span></span>
<span class="line"><span style="color:#A6ACCD;">const task = (wait, light, callback) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        switch (light) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            case &#39;red&#39;:</span></span>
<span class="line"><span style="color:#A6ACCD;">                red()</span></span>
<span class="line"><span style="color:#A6ACCD;">                break</span></span>
<span class="line"><span style="color:#A6ACCD;">            case &#39;green&#39;:</span></span>
<span class="line"><span style="color:#A6ACCD;">                green()</span></span>
<span class="line"><span style="color:#A6ACCD;">                break</span></span>
<span class="line"><span style="color:#A6ACCD;">            case &#39;yellow&#39;:</span></span>
<span class="line"><span style="color:#A6ACCD;">                yellow()</span></span>
<span class="line"><span style="color:#A6ACCD;">                break</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        callback()</span></span>
<span class="line"><span style="color:#A6ACCD;">    }, wait)</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">const step = () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    task(3000, &#39;red&#39;, () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        task(2000, &#39;green&#39;, () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            task(1000, &#39;yellow&#39;, step)</span></span>
<span class="line"><span style="color:#A6ACCD;">        })</span></span>
<span class="line"><span style="color:#A6ACCD;">    })</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">// step()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// promise 实现</span></span>
<span class="line"><span style="color:#A6ACCD;">const taskPromise = (wait, light) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return new Promise (resolve =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            switch (light) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                case &#39;red&#39;:</span></span>
<span class="line"><span style="color:#A6ACCD;">                    red()</span></span>
<span class="line"><span style="color:#A6ACCD;">                    break</span></span>
<span class="line"><span style="color:#A6ACCD;">                case &#39;green&#39;:</span></span>
<span class="line"><span style="color:#A6ACCD;">                    green()</span></span>
<span class="line"><span style="color:#A6ACCD;">                    break</span></span>
<span class="line"><span style="color:#A6ACCD;">                case &#39;yellow&#39;:</span></span>
<span class="line"><span style="color:#A6ACCD;">                    yellow()</span></span>
<span class="line"><span style="color:#A6ACCD;">                    break</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">            resolve()</span></span>
<span class="line"><span style="color:#A6ACCD;">        }, wait)</span></span>
<span class="line"><span style="color:#A6ACCD;">    })</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">const setpPromise = () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    taskPromise(3000, &#39;red&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">        .then(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            taskPromise(2000, &#39;green&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">        })</span></span>
<span class="line"><span style="color:#A6ACCD;">        .then(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            taskPromise(1000, &#39;yellow&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">        })</span></span>
<span class="line"><span style="color:#A6ACCD;">        .then(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            setpPromise()</span></span>
<span class="line"><span style="color:#A6ACCD;">        })</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">// setpPromise()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const stepRunner = async () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    await taskPromise(3000, &#39;red&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    await taskPromise(2000, &#39;green&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    await taskPromise(1000, &#39;yellow&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    stepRunner()</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">stepRunner()</span></span></code></pre></div><h2 id="_29-间隔打印" tabindex="-1">29.间隔打印 <a class="header-anchor" href="#_29-间隔打印" aria-label="Permalink to &quot;29.间隔打印&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">for (let i=0; i&lt;5; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(i)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }, i * 1000)</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><h2 id="_30-es6创建类" tabindex="-1">30.ES6创建类 <a class="header-anchor" href="#_30-es6创建类" aria-label="Permalink to &quot;30.ES6创建类&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Employee {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (name, dept) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.name = name</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.dept = dept</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.age = 18</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 静态方法</span></span>
<span class="line"><span style="color:#A6ACCD;">    static fun () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;static&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    getName () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(this.name)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Employee.fun() // static</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const well  = new Employee(&#39;well&#39;, &#39;dev&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(well) // Employee { name: &#39;well&#39;, dept: &#39;dev&#39;, age: 18 } </span></span>
<span class="line"><span style="color:#A6ACCD;">// well.fun() // well.fun is not a function</span></span>
<span class="line"><span style="color:#A6ACCD;">well.getName()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// extends继承父类创建子类</span></span>
<span class="line"><span style="color:#A6ACCD;">class Manager extends Employee {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (name, dept, reports) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        super(name, dept)</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.reports = reports</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">const wellManager = new Manager(&#39;wellManager&#39;, &#39;dev&#39;, 1)</span></span>
<span class="line"><span style="color:#A6ACCD;">Manager.fun() // static</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(wellManager) // Manager { name: &#39;wellManager&#39;, dept: &#39;dev&#39;, age: 18, reports: 1 } </span></span>
<span class="line"><span style="color:#A6ACCD;">wellManager.getName() // wellManager</span></span></code></pre></div><ul><li>constructor：构造函数，相当于ES5的构造函数，里面的this.×××的属性可以实例化给对象</li><li>static：静态属性，不会随着实例化给对象，但是可以通过extends继承。</li><li>非 static 方法可以随着实例化给对象。</li></ul><h2 id="_31-es5-创建类" tabindex="-1">31.ES5 创建类 <a class="header-anchor" href="#_31-es5-创建类" aria-label="Permalink to &quot;31.ES5 创建类&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function Employee (name, dept) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    this.name =  name</span></span>
<span class="line"><span style="color:#A6ACCD;">    this.dept = dept</span></span>
<span class="line"><span style="color:#A6ACCD;">    this.age = 18</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">// 静态方法</span></span>
<span class="line"><span style="color:#A6ACCD;">Employee.fun = function () {</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(&#39;static&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">Employee.prototype.getName = function () {</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(this.name)</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">const well = new Employee(&#39;well&#39;, &#39;dev&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(well) // Employee { name: &#39;well&#39;, dept: &#39;dev&#39;, age: 18 }</span></span>
<span class="line"><span style="color:#A6ACCD;">Employee.fun() // static</span></span>
<span class="line"><span style="color:#A6ACCD;">// well.fun() // Employee.fun is not a function</span></span>
<span class="line"><span style="color:#A6ACCD;">well.getName()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 继承</span></span>
<span class="line"><span style="color:#A6ACCD;">function Manager(name, dept, reports) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 调用 Employee 函数，并把this执行Manger，所以完成了</span></span>
<span class="line"><span style="color:#A6ACCD;">    // this.name = name</span></span>
<span class="line"><span style="color:#A6ACCD;">    // this.dept = dept</span></span>
<span class="line"><span style="color:#A6ACCD;">    Employee.call(this, name, dept)</span></span>
<span class="line"><span style="color:#A6ACCD;">    this.reports = reports</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const wellManager = new Manager(&#39;wellManager&#39;, &#39;dev&#39;, 1)</span></span>
<span class="line"><span style="color:#A6ACCD;">// Manager.fun() // Manager.fun is not a function</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(wellManager) // Manager { name: &#39;wellManager&#39;, dept: &#39;dev&#39;, age: 18, reports: 1 } </span></span>
<span class="line"><span style="color:#A6ACCD;">// wellManager.getName() // wellManager.getName is not a function</span></span></code></pre></div><ul><li>静态属性添加</li><li>原型属性添加</li><li>继承实现 <ul><li>继承不了原型属性</li><li>继承不了静态属性</li></ul></li></ul></div></div></main><footer class="VPDocFooter" data-v-a3c25e27 data-v-5774f702><!--[--><!--]--><div class="edit-info" data-v-5774f702><!----><div class="last-updated" data-v-5774f702><p class="VPLastUpdated" data-v-5774f702 data-v-b89b6307>Last updated: <time datetime="2023-08-05T12:47:31.000Z" data-v-b89b6307></time></p></div></div><nav class="prev-next" data-v-5774f702><div class="pager" data-v-5774f702><a class="pager-link prev" href="/blog/interview/codeconsole.html" data-v-5774f702><span class="desc" data-v-5774f702>Previous page</span><span class="title" data-v-5774f702>代码输出</span></a></div><div class="pager" data-v-5774f702><a class="pager-link next" href="/blog/interview/browser.html" data-v-5774f702><span class="desc" data-v-5774f702>Next page</span><span class="title" data-v-5774f702>浏览器原理</span></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"readme.md\":\"9fe2bbf2\",\"readme.en.md\":\"eaadeb5d\",\"interview_miniwechat.md\":\"d977b9d2\",\"article_vuecomponent_usets.md\":\"180b5915\",\"alg_hash.md\":\"0d261b36\",\"article_react_reactbasic.md\":\"8e73c160\",\"interview_experience.md\":\"a9317a38\",\"article_vuecomponent_monorepo.md\":\"4e04216a\",\"article_project_normalizeconfig.md\":\"39d23d0b\",\"article_requirement_binary.md\":\"1e140587\",\"index.md\":\"a4192508\",\"interview_vue.md\":\"60363d6c\",\"article_project_modulestandard.md\":\"a4d90dae\",\"interview_performance.md\":\"cdb4bb5a\",\"article_react_reactusets.md\":\"2fea022f\",\"node_mongodb.md\":\"f60d5598\",\"interview_softskill.md\":\"9d1c9f3c\",\"article_project_rollup_vite.md\":\"b8518f6c\",\"article_wheel_lazyload.md\":\"a0116601\",\"article_react_reacthooks.md\":\"a7b6f542\",\"article_project_webpackconfig.md\":\"72ec81d1\",\"node_nodebasic.md\":\"08b016d6\",\"alg_array.md\":\"285e035c\",\"interview_browser.md\":\"e4f87485\",\"article_vuecomponent_bem.md\":\"f76ce9fa\",\"interview_codeconsole.md\":\"126c0a41\",\"interview_javascript.md\":\"6a379c53\",\"article_react_reactusecss.md\":\"a6adaacf\",\"alg_slidewindow.md\":\"93e95a53\",\"article_requirement_upload.md\":\"1e075c3d\",\"interview_html.md\":\"5e20e85b\",\"alg_sorting.md\":\"a154f413\",\"interview_css.md\":\"2d3d234d\",\"interview_network.md\":\"413538c0\",\"interview_writecode.md\":\"47d3b640\",\"node_koa.md\":\"cce0fcff\",\"node_express.md\":\"9049c5ac\",\"interview_networkinterview.md\":\"6d09c46c\",\"article_wheel_scrolllist.md\":\"bff814f0\",\"interview_typescript.md\":\"91b27097\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"well's blog\",\"description\":\"well's blog\",\"base\":\"/blog/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"lastUpdated\":\"最后更新时间\",\"docsDir\":\"docs\",\"editLinks\":true,\"editLinkText\":\"编辑此网站\",\"repo\":\"https://gitee.com/wayliuhaha/blog\",\"nav\":[{\"text\":\"文档\",\"link\":\"/article/project/normalizeConfig\",\"activeMatch\":\"/article/\"},{\"text\":\"node\",\"link\":\"/node/nodeBasic\",\"activeMatch\":\"/node/\"},{\"text\":\"不止于面试\",\"link\":\"/interview/css\",\"activeMatch\":\"/interview/\"},{\"text\":\"算法\",\"link\":\"/alg/array\",\"activeMatch\":\"/alg/\"}],\"sidebar\":{\"/node/\":[{\"text\":\"node 基础\",\"link\":\"/node/nodeBasic\"},{\"text\":\"mongoDB\",\"link\":\"/node/mongoDB\"},{\"text\":\"express\",\"link\":\"/node/express\"},{\"text\":\"koa\",\"link\":\"/node/koa\"}],\"/article/\":[{\"text\":\"文档\",\"items\":[{\"text\":\"项目工程化\",\"items\":[{\"text\":\"规范化配置\",\"link\":\"/article/project/normalizeConfig\"},{\"text\":\"打包工具-webpack\",\"link\":\"/article/project/webpackConfig\"},{\"text\":\"rollup&webpack\",\"link\":\"/article/project/rollup&vite\"},{\"text\":\"前端模块化规范\",\"link\":\"/article/project/moduleStandard\"}]},{\"text\":\"轮子原理\",\"items\":[{\"text\":\"图片懒加载\",\"link\":\"/article/wheel/lazyload\"},{\"text\":\"虚拟滚动列表\",\"link\":\"/article/wheel/scrollList\"}]},{\"text\":\"vue3 通用组件\",\"items\":[{\"text\":\"Monorepo\",\"link\":\"/article/vueComponent/monorepo\"},{\"text\":\"ts 类型约束\",\"link\":\"/article/vueComponent/usets \"},{\"text\":\"BEM 规范\",\"link\":\"/article/vueComponent/bem\"}]},{\"text\":\"React\",\"items\":[{\"text\":\"react 基础\",\"link\":\"/article/react/reactBasic\"},{\"text\":\"react hooks\",\"link\":\"/article/react/reactHooks\"},{\"text\":\"react 使用ts指南\",\"link\":\"/article/react/reactUseTs\"},{\"text\":\"react 使用css\",\"link\":\"/article/react/reactUseCss\"}]},{\"text\":\"常见需求处理\",\"items\":[{\"text\":\"二进制\",\"link\":\"/article/requirement/binary\"},{\"text\":\"文件上传\",\"link\":\"/article/requirement/upload\"}]}]}],\"/interview\":[{\"text\":\"不止于面试\",\"items\":[{\"text\":\"css\",\"link\":\"/interview/css\"},{\"text\":\"html\",\"link\":\"/interview/html\"},{\"text\":\"javascript\",\"link\":\"/interview/javascript\"},{\"text\":\"typescript\",\"link\":\"/interview/typescript\"},{\"text\":\"vue\",\"link\":\"/interview/vue\"},{\"text\":\"代码输出\",\"link\":\"/interview/codeconsole\"},{\"text\":\"手写代码\",\"link\":\"/interview/writecode\"},{\"text\":\"浏览器原理\",\"link\":\"/interview/browser\"},{\"text\":\"计算机网络\",\"link\":\"/interview/network\"},{\"text\":\"计算机网络（面试）\",\"link\":\"/interview/networkinterview\"},{\"text\":\"微信小程序\",\"link\":\"/interview/miniwechat\"},{\"text\":\"性能优化\",\"link\":\"/interview/performance\"},{\"text\":\"软技能\",\"link\":\"/interview/softskill\"},{\"text\":\"面经\",\"link\":\"/interview/experience\"}]}],\"/alg\":[{\"text\":\"算法\",\"items\":[{\"text\":\"数组/字符串\",\"link\":\"/alg/array\"},{\"text\":\"滑动窗口\",\"link\":\"/alg/slidewindow\"},{\"text\":\"哈希表\",\"link\":\"/alg/hash\"},{\"text\":\"排序算法\",\"link\":\"/alg/sorting\"}]}]}},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}");</script>
    
  </body>
</html>