<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>well's blog | well's blog</title>
    <meta name="description" content="well's blog">
    <link rel="preload stylesheet" href="/blog/assets/style.01456bfa.css" as="style">
    
    <script type="module" src="/blog/assets/app.99e7a8b1.js"></script>
    <link rel="preload" href="/blog/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/blog/assets/chunks/framework.9adb0f96.js">
    <link rel="modulepreload" href="/blog/assets/chunks/theme.0198b334.js">
    <link rel="modulepreload" href="/blog/assets/alg_array.md.285e035c.lean.js">
    <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-ffdc1df7><!--[--><!--]--><!--[--><span tabindex="-1" data-v-9c8615dd></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-9c8615dd> Skip to content </a><!--]--><!----><header class="VPNav" data-v-ffdc1df7 data-v-5bdc5df3><div class="VPNavBar has-sidebar" data-v-5bdc5df3 data-v-4077a65e><div class="container" data-v-4077a65e><div class="title" data-v-4077a65e><div class="VPNavBarTitle has-sidebar" data-v-4077a65e data-v-6d57964e><a class="title" href="/blog/" data-v-6d57964e><!--[--><!--]--><!----><!--[-->well&#39;s blog<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-4077a65e><div class="curtain" data-v-4077a65e></div><div class="content-body" data-v-4077a65e><!--[--><!--]--><div class="VPNavBarSearch search" style="--vp-meta-key:&#39;Meta&#39;;" data-v-4077a65e><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-4077a65e data-v-f732b5d0><span id="main-nav-aria-label" class="visually-hidden" data-v-f732b5d0>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/article/project/normalizeConfig.html" tabindex="0" data-v-f732b5d0 data-v-7f10a92a><!--[-->文档<!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/node/nodeBasic.html" tabindex="0" data-v-f732b5d0 data-v-7f10a92a><!--[-->node<!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/interview/css.html" tabindex="0" data-v-f732b5d0 data-v-7f10a92a><!--[-->不止于面试<!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/blog/alg/array.html" tabindex="0" data-v-f732b5d0 data-v-7f10a92a><!--[-->算法<!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-4077a65e data-v-5e9f0637><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-5e9f0637 data-v-a99ed743 data-v-92d8f6fb><span class="check" data-v-92d8f6fb><span class="icon" data-v-92d8f6fb><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-a99ed743><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-a99ed743><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-4077a65e data-v-c8c2ae4b data-v-6afe904b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-6afe904b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-6afe904b><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-6afe904b><div class="VPMenu" data-v-6afe904b data-v-e42ed9b3><!----><!--[--><!--[--><!----><div class="group" data-v-c8c2ae4b><div class="item appearance" data-v-c8c2ae4b><p class="label" data-v-c8c2ae4b>Appearance</p><div class="appearance-action" data-v-c8c2ae4b><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-c8c2ae4b data-v-a99ed743 data-v-92d8f6fb><span class="check" data-v-92d8f6fb><span class="icon" data-v-92d8f6fb><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-a99ed743><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-a99ed743><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-4077a65e data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav reached-top" data-v-ffdc1df7 data-v-693d654a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-693d654a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-693d654a><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-693d654a>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-693d654a data-v-bd10e8af><button data-v-bd10e8af>Return to top</button><!----></div></div><aside class="VPSidebar" data-v-ffdc1df7 data-v-b04a928c><div class="curtain" data-v-b04a928c></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-b04a928c><span class="visually-hidden" id="sidebar-aria-label" data-v-b04a928c> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-b04a928c><section class="VPSidebarItem level-0 has-active" data-v-b04a928c data-v-66c2f55a><div class="item" role="button" tabindex="0" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><h2 class="text" data-v-66c2f55a>算法</h2><!----></div><div class="items" data-v-66c2f55a><!--[--><div class="VPSidebarItem level-1 is-link is-active has-active" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/alg/array.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>数组/字符串</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/alg/slidewindow.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>滑动窗口</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/alg/hash.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>哈希表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/alg/dobulePointer.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>双指针</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/alg/stack.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>栈</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/alg/range.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>区间</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/alg/linkedList.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>链表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-66c2f55a data-v-66c2f55a><div class="item" data-v-66c2f55a><div class="indicator" data-v-66c2f55a></div><a class="VPLink link link" href="/blog/alg/sorting.html" data-v-66c2f55a><!--[--><p class="text" data-v-66c2f55a>排序算法</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-ffdc1df7 data-v-f0629f57><div class="VPDoc has-sidebar has-aside" data-v-f0629f57 data-v-a3c25e27><!--[--><!--]--><div class="container" data-v-a3c25e27><div class="aside" data-v-a3c25e27><div class="aside-curtain" data-v-a3c25e27></div><div class="aside-container" data-v-a3c25e27><div class="aside-content" data-v-a3c25e27><div class="VPDocAside" data-v-a3c25e27 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-cb998dce data-v-c834746b><div class="content" data-v-c834746b><div class="outline-marker" data-v-c834746b></div><div class="outline-title" data-v-c834746b>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-c834746b><span class="visually-hidden" id="doc-outline-aria-label" data-v-c834746b> Table of Contents for current page </span><ul class="root" data-v-c834746b data-v-89c8d7c6><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-a3c25e27><div class="content-container" data-v-a3c25e27><!--[--><!--]--><!----><main class="main" data-v-a3c25e27><div style="position:relative;" class="vp-doc _blog_alg_array" data-v-a3c25e27><div><h2 id="两数之和" tabindex="-1">两数之和 <a class="header-anchor" href="#两数之和" aria-label="Permalink to &quot;两数之和&quot;">​</a></h2><h3 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：nums = [2,7,11,15], target = 9</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：[0,1]</span></span>
<span class="line"><span style="color:#A6ACCD;">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span></span></code></pre></div><h3 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-label="Permalink to &quot;思路&quot;">​</a></h3><p>构造一个<code>map</code>, 将遍历的数字作为key，下标作为值</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var twoSum = function(nums, target) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    const map = new Map()</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;nums.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (map.has(target - nums[i])) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            return [map.get(target - nums[i]), i]</span></span>
<span class="line"><span style="color:#A6ACCD;">        } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">            map.set(nums[i], i)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><h2 id="三数之和" tabindex="-1">三数之和 <a class="header-anchor" href="#三数之和" aria-label="Permalink to &quot;三数之和&quot;">​</a></h2><h3 id="题目-1" tabindex="-1">题目 <a class="header-anchor" href="#题目-1" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>给定一个包含 <code>n</code> 个整数的数组<code>nums</code>，判断 <code>nums</code> 中是否存在三个元素<code>a，b，c</code> ，使得 <code>a + b + c = 0 ？</code>找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">例如</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> 给定数组 nums </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">]，</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">满足要求的三元组集合为：</span></span>
<span class="line"><span style="color:#A6ACCD;">[</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">]</span></span></code></pre></div><h3 id="思路-1" tabindex="-1">思路 <a class="header-anchor" href="#思路-1" aria-label="Permalink to &quot;思路&quot;">​</a></h3><ul><li>利用排序+双指针</li><li>先固定一个，剩余的前后作为前指针和后指针向中间移动</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var threeSum = function(nums) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let result = []</span></span>
<span class="line"><span style="color:#A6ACCD;">    nums = nums.sort((a,b) =&gt; a - b)</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;nums.length-2; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 如果全部大于0则结束</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (nums[i] &gt; 0) break</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 过滤当前和前一个一样</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (i&gt;0 &amp;&amp; nums[i] === nums[i-1]) continue</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 前指针</span></span>
<span class="line"><span style="color:#A6ACCD;">        let L = i+1</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 后指针</span></span>
<span class="line"><span style="color:#A6ACCD;">        let R = nums.length -1</span></span>
<span class="line"><span style="color:#A6ACCD;">        while(L&lt;R) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            const sum = nums[i] + nums[L] + nums[R]</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (sum === 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                result.push([nums[i], nums[L], nums[R]])</span></span>
<span class="line"><span style="color:#A6ACCD;">                // 前指针去重</span></span>
<span class="line"><span style="color:#A6ACCD;">                while(L&lt;R &amp;&amp; nums[L] === nums[L+1]) L++</span></span>
<span class="line"><span style="color:#A6ACCD;">                // 后指针去重</span></span>
<span class="line"><span style="color:#A6ACCD;">                while(L&lt;R &amp;&amp; nums[R] === nums[R-1]) R--</span></span>
<span class="line"><span style="color:#A6ACCD;">                L++</span></span>
<span class="line"><span style="color:#A6ACCD;">                R--</span></span>
<span class="line"><span style="color:#A6ACCD;">            } else if (sum &lt; 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                L++</span></span>
<span class="line"><span style="color:#A6ACCD;">            } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">                R--</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return result</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><h2 id="四数之和" tabindex="-1">四数之和 <a class="header-anchor" href="#四数之和" aria-label="Permalink to &quot;四数之和&quot;">​</a></h2><h3 id="题目-2" tabindex="-1">题目 <a class="header-anchor" href="#题目-2" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>给定一个包含 <code>n</code> 个整数的数组<code>nums</code>，判断 <code>nums</code> 中是否存在四个元素<code>a，b，c，d</code> ，使得 <code>a + b + c + d = 0 ？</code>找出所有满足条件且不重复的四元组。</p><p>注意：答案中不可以包含重复的四元组。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">给定数组 nums </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">]，和 target </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">满足要求的四元组集合为：</span></span>
<span class="line"><span style="color:#A6ACCD;">[</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">  </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">  </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">]</span></span></code></pre></div><h3 id="思路-2" tabindex="-1">思路 <a class="header-anchor" href="#思路-2" aria-label="Permalink to &quot;思路&quot;">​</a></h3><p>通过大小指针降低复杂度</p><ul><li>过滤和前一个相同的</li><li>前后指针记得去重</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var fourSum = function(nums, target) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    nums = nums.sort((a, b) =&gt; a - b)</span></span>
<span class="line"><span style="color:#A6ACCD;">    const result = []</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;nums.length-3; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 过滤和前一个重复</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (i&gt;0 &amp; nums[i] === nums[i-1]) continue</span></span>
<span class="line"><span style="color:#A6ACCD;">        for (let j=i+1; j&lt;nums.length-2; j++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            // 过滤和前一个重复</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (j&gt;i+1 &amp;&amp; nums[j] === nums[j-1]) continue</span></span>
<span class="line"><span style="color:#A6ACCD;">             // 前后指针</span></span>
<span class="line"><span style="color:#A6ACCD;">            let left = j+1</span></span>
<span class="line"><span style="color:#A6ACCD;">            let right = nums.length-1</span></span>
<span class="line"><span style="color:#A6ACCD;">            while(left&lt;right) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                const sum = nums[i] + nums[j] + nums[left] + nums[right]</span></span>
<span class="line"><span style="color:#A6ACCD;">                if (sum === target) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                    result.push([nums[i], nums[j], nums[left], nums[right]])</span></span>
<span class="line"><span style="color:#A6ACCD;">                    // 前指针去重</span></span>
<span class="line"><span style="color:#A6ACCD;">                    while (left&lt;right &amp;&amp; nums[left] === nums[left+1]) left++</span></span>
<span class="line"><span style="color:#A6ACCD;">                    // 后指针去重</span></span>
<span class="line"><span style="color:#A6ACCD;">                    while (left&lt;right &amp;&amp; nums[right] === nums[right-1]) right--</span></span>
<span class="line"><span style="color:#A6ACCD;">                    left++</span></span>
<span class="line"><span style="color:#A6ACCD;">                    right--</span></span>
<span class="line"><span style="color:#A6ACCD;">                } else if (sum &lt; target) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                    left++</span></span>
<span class="line"><span style="color:#A6ACCD;">                } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">                    right--</span></span>
<span class="line"><span style="color:#A6ACCD;">                }</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return result</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><h2 id="把数组排成最小的数" tabindex="-1">把数组排成最小的数 <a class="header-anchor" href="#把数组排成最小的数" aria-label="Permalink to &quot;把数组排成最小的数&quot;">​</a></h2><h3 id="题目-3" tabindex="-1">题目 <a class="header-anchor" href="#题目-3" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入: [10,2]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出: &quot;102</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">输入: [3,30,34,5,9]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出: &quot;3033459&quot;</span></span></code></pre></div><h3 id="思路-3" tabindex="-1">思路 <a class="header-anchor" href="#思路-3" aria-label="Permalink to &quot;思路&quot;">​</a></h3><ul><li>若拼接字符串 <code>x+y&gt;y+x</code>,则x&gt;y,否则y&gt;=x</li><li>在拼接的时候只需要做一个排序（升序）即可</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var minNumber = function(nums) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;nums.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        for (let j=0; j&lt;nums.length-i-1; j++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (`${nums[j]}${nums[j+1]}` &gt; `${nums[j+1]}${nums[j]}`) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                [nums[j], nums[j+1]] = [nums[j+1], nums[j]]</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return nums.join(&#39;&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><h2 id="第一个只出现一次的字符" tabindex="-1">第一个只出现一次的字符 <a class="header-anchor" href="#第一个只出现一次的字符" aria-label="Permalink to &quot;第一个只出现一次的字符&quot;">​</a></h2><h3 id="题目-4" tabindex="-1">题目 <a class="header-anchor" href="#题目-4" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：s = &quot;abaccdeff&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：&#39;b&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">输入：s = &quot;&quot; </span></span>
<span class="line"><span style="color:#A6ACCD;">输出：&#39; &#39;</span></span></code></pre></div><h3 id="思想" tabindex="-1">思想 <a class="header-anchor" href="#思想" aria-label="Permalink to &quot;思想&quot;">​</a></h3><ol><li>遍历维护一个map记录存在状态（多次-1），遍历返回不为-1的第一个</li><li>遍历维护一个map记录存在状态（多次-1），同时维护一个队列记录数值和状态（多次-1），当map存在的时候，如果对头中存在key映射到map为-1的，则出队</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var firstUniqChar = function(s) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    const map = new Map()</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;s.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (map.has(s[i])) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            map.set(s[i], -1)</span></span>
<span class="line"><span style="color:#A6ACCD;">        } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">            map.set(s[i], i)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;s.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (map.get(s[i]) !== -1) return s[i]</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return &#39; &#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var firstUniqChar = function(s) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    const map = new Map()</span></span>
<span class="line"><span style="color:#A6ACCD;">    const queue = []</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;s.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (map.has(s[i])) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            // 如果多次状态为-1</span></span>
<span class="line"><span style="color:#A6ACCD;">            map.set(s[i], -1)</span></span>
<span class="line"><span style="color:#A6ACCD;">            // 只要队头存在映射到map为-1 的，则出队</span></span>
<span class="line"><span style="color:#A6ACCD;">            while(queue.length &amp;&amp; map.get(queue[0][0]) === -1) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                queue.shift()</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">            map.set(s[i], i)</span></span>
<span class="line"><span style="color:#A6ACCD;">            queue.push([s[i], i])</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return queue.length ? queue[0][0] : &#39; &#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><h2 id="调整数组顺序使奇数位于偶数前面" tabindex="-1">调整数组顺序使奇数位于偶数前面 <a class="header-anchor" href="#调整数组顺序使奇数位于偶数前面" aria-label="Permalink to &quot;调整数组顺序使奇数位于偶数前面&quot;">​</a></h2><h3 id="题目-5" tabindex="-1">题目 <a class="header-anchor" href="#题目-5" aria-label="Permalink to &quot;题目&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：nums = [1,2,3,4]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：[1,3,2,4] </span></span>
<span class="line"><span style="color:#A6ACCD;">注：[3,1,2,4] 也是正确的答案之一。</span></span></code></pre></div><h3 id="思想-1" tabindex="-1">思想 <a class="header-anchor" href="#思想-1" aria-label="Permalink to &quot;思想&quot;">​</a></h3><p>双指针 + 一次遍历，首尾往中间</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var exchange = function(nums) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let left = 0</span></span>
<span class="line"><span style="color:#A6ACCD;">    let right = nums.length-1</span></span>
<span class="line"><span style="color:#A6ACCD;">    while(left&lt;right) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        while(left&lt;right &amp;&amp; nums[left] % 2 === 1) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            left++</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        while(left&lt;right &amp;&amp; nums[right] % 2 === 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            right--</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (left&lt;right) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            [nums[left], nums[right]] = [nums[right], nums[left]]</span></span>
<span class="line"><span style="color:#A6ACCD;">            left++</span></span>
<span class="line"><span style="color:#A6ACCD;">            right--</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return nums</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><h2 id="下一个队列" tabindex="-1">下一个队列 <a class="header-anchor" href="#下一个队列" aria-label="Permalink to &quot;下一个队列&quot;">​</a></h2><h3 id="题目-6" tabindex="-1">题目 <a class="header-anchor" href="#题目-6" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 必须 <strong>原地</strong> 修改，只允许使用额外常数空间。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：nums = [1,2,3]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：[1,3,2]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">输入：nums = [3,2,1]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：[1,2,3]</span></span></code></pre></div><h3 id="思想-2" tabindex="-1">思想 <a class="header-anchor" href="#思想-2" aria-label="Permalink to &quot;思想&quot;">​</a></h3><ul><li>需要将左边【较小数】与右边【较大数】交换，从而让排列变大</li><li>让【较小数】尽量靠右，【较大数】尽可能小</li><li>[4,5,2,6,3,1] <ul><li>找到符合【较小数】与【较大数】为2与3</li><li>交换后为[4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]</li></ul></li><li>算法描述 <ul><li>从后向前查找第一个顺序对(i, i+1), 满足<code>a[i]&lt;a[i+1]</code>，较小数即为a[i],此时<code>[i+1, n)</code>必然是降序的</li><li>找到了顺序对，在区间<code>[i+1, n)</code> 中从后向前查找第一个元素 j 满足 a[i] &lt; a[j],较大数为a[j]</li><li>交换a[i]与a[j],<code>[i+1, n)</code>是降序的，反转使其变为升序即可</li></ul></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var nextPermutation = function(nums) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let i = nums.length - 2</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 找到较小数下标</span></span>
<span class="line"><span style="color:#A6ACCD;">    while(i&gt;=0 &amp;&amp; nums[i] &gt;= nums[i+1]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        i--</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 找到较大数下标</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (i &gt;= 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        let j = nums.length - 1</span></span>
<span class="line"><span style="color:#A6ACCD;">        while(j&gt;=0 &amp;&amp; nums[i] &gt;= nums[j]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            j--</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 交换较小较大数</span></span>
<span class="line"><span style="color:#A6ACCD;">        [nums[i], nums[j]] = [nums[j], nums[i]]</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 升序交换</span></span>
<span class="line"><span style="color:#A6ACCD;">    let left = i+1</span></span>
<span class="line"><span style="color:#A6ACCD;">    let right = nums.length - 1</span></span>
<span class="line"><span style="color:#A6ACCD;">    while(left&lt;right) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        [nums[left], nums[right]] = [nums[right], nums[left]]</span></span>
<span class="line"><span style="color:#A6ACCD;">        left++</span></span>
<span class="line"><span style="color:#A6ACCD;">        right--</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><h2 id="搜索螺旋排序数组" tabindex="-1">搜索螺旋排序数组 <a class="header-anchor" href="#搜索螺旋排序数组" aria-label="Permalink to &quot;搜索螺旋排序数组&quot;">​</a></h2><h3 id="题目-7" tabindex="-1">题目 <a class="header-anchor" href="#题目-7" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：nums = [4,5,6,7,0,1,2], target = 0</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：4</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">输入：nums = [4,5,6,7,0,1,2], target = 3</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：-1</span></span></code></pre></div><h3 id="思想-3" tabindex="-1">思想 <a class="header-anchor" href="#思想-3" aria-label="Permalink to &quot;思想&quot;">​</a></h3><ul><li>利用二分查找的方法，确认哪一部分是有序的，从有序的之中再次进行查找</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var search = function (nums, target) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let left = 0</span></span>
<span class="line"><span style="color:#A6ACCD;">    let right = nums.length - 1</span></span>
<span class="line"><span style="color:#A6ACCD;">    while (left &lt;= right) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        let middle = Math.floor((left + right) / 2)</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (nums[middle] === target) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            return middle</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">        // middle 在数组的左段</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (nums[0] &lt;= nums[middle]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (nums[0] &lt;= target &amp;&amp; target &lt; nums[middle]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                right = middle - 1</span></span>
<span class="line"><span style="color:#A6ACCD;">            } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">                left = middle + 1</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">            // middle 在数组的右段</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (nums[middle] &lt; target &amp;&amp; target &lt;= nums[nums.length - 1]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                left = middle + 1</span></span>
<span class="line"><span style="color:#A6ACCD;">            } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">                right = middle - 1</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return -1</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><h2 id="缺失的第一个正数" tabindex="-1">缺失的第一个正数 <a class="header-anchor" href="#缺失的第一个正数" aria-label="Permalink to &quot;缺失的第一个正数&quot;">​</a></h2><h3 id="题目-8" tabindex="-1">题目 <a class="header-anchor" href="#题目-8" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：nums = [1,2,0]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：3</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">输入：nums = [3,4,-1,1]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：2</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">输入：nums = [7,8,9,11,12]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：1</span></span></code></pre></div><h3 id="思想-4" tabindex="-1">思想 <a class="header-anchor" href="#思想-4" aria-label="Permalink to &quot;思想&quot;">​</a></h3><ul><li><p>使用常量</p><ul><li>构建一个数组，把源数据作为改数组下标</li><li>从1开始遍历，如果没有对应的则是最小的第一个正数</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var firstMissingPositive = function (nums) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let arr = []</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i = 0; i &lt; nums.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (nums[i] &gt; 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            arr[nums[i]] = nums[i]</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let j = 1; j &lt; arr.length; j++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (!arr[j]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            return j</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return arr.length ? arr[arr.length - 1] + 1 : 1</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div></li><li><p>不使用常量</p><p><img src="/blog/assets/image-20230803130609147.87e0001c.png" alt="image-20230803130609147"></p><ul><li>长度为N的数组，没有出现的最小整数只能在[1, N+1]中</li><li>[1, N]都出现，则是N+1,否则出现在[1, N]</li><li>对数组遍历得到当前数<strong>x</strong>，如果在[1, N],则将数组中<strong>x-1</strong>（从0开始）个位置标记</li><li>遍历结束后，如果都打了标记则是N+1,否则是最小的没有打标记的位置加1</li><li>算法过程 <ul><li>将数组小于等于0的数修改为N+1</li><li>遍历数组得到<strong>x</strong>,（可能被打了标记（负号））取<code>|x|</code>如果在[1, N]，给数组中<code>|x|-1</code>个位置添加一个负号</li><li>遍历完之后，如果每一个数都是负数，那么答案是N+1,否则第一个正数位置加1</li></ul></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var firstMissingPositive = function (nums) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    const n = nums.length</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 小于等于0的修改为 n+1</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;n; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (nums[i]&lt;=0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            nums[i] = n + 1</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 范围内的值将其对应下标的值变为负数</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;n; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        const num = Math.abs(nums[i])</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (num &lt;= n) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            nums[num-1] = -Math.abs(nums[num-1])</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 找到第一个不为负数的值</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=0; i&lt;n; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (nums[i] &gt; 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            return i+1</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return n + 1</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div></li></ul><h2 id="合并区间" tabindex="-1">合并区间 <a class="header-anchor" href="#合并区间" aria-label="Permalink to &quot;合并区间&quot;">​</a></h2><h3 id="题目-9" tabindex="-1">题目 <a class="header-anchor" href="#题目-9" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：[[1,6],[8,10],[15,18]]</span></span>
<span class="line"><span style="color:#A6ACCD;">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">输入：intervals = [[1,4],[4,5]]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：[[1,5]]</span></span>
<span class="line"><span style="color:#A6ACCD;">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span></span></code></pre></div><h3 id="思想-5" tabindex="-1">思想 <a class="header-anchor" href="#思想-5" aria-label="Permalink to &quot;思想&quot;">​</a></h3><ul><li>按照区间左端点升序排序，排完序的列表中，可以合并的区间一定是连续的</li><li>如果当前区间的左端点在<code>merged</code>中最后一个区间的右端点后，则他们是不重合的</li><li>否则是重合的，更新右端点较大值即可 <img src="/blog/assets/合并区间.1ccc5c34.png" alt="合并区间"></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var merge = function (intervals) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  if (intervals.length === 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return [];</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 升序排序</span></span>
<span class="line"><span style="color:#A6ACCD;">  intervals.sort((interval1, interval2) =&gt; interval1[0] - interval2[0]);</span></span>
<span class="line"><span style="color:#A6ACCD;">  const merged = [];</span></span>
<span class="line"><span style="color:#A6ACCD;">  for (let i = 0; i &lt; intervals.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let [L, R] = intervals[i];</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (merged.length === 0 || merged[merged.length - 1][1] &lt; L) {</span></span>
<span class="line"><span style="color:#A6ACCD;">      // 如果合并数组中大值小于当前的小值,证明不属于这个区间</span></span>
<span class="line"><span style="color:#A6ACCD;">      merged.push([L, R]);</span></span>
<span class="line"><span style="color:#A6ACCD;">    } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">      // 属于这个区间，重新获取这个区间的大值</span></span>
<span class="line"><span style="color:#A6ACCD;">      merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], R);</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">  return merged;</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><h2 id="寻找峰值" tabindex="-1">寻找峰值 <a class="header-anchor" href="#寻找峰值" aria-label="Permalink to &quot;寻找峰值&quot;">​</a></h2><h3 id="题目-10" tabindex="-1">题目 <a class="header-anchor" href="#题目-10" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] = nums[n] = -∞ 。</p><p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：nums = [1,2,3,1]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：2</span></span>
<span class="line"><span style="color:#A6ACCD;">解释：3 是峰值元素，你的函数应该返回其索引 2。</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：nums = [1,2,1,3,5,6,4]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：1 或 5 </span></span>
<span class="line"><span style="color:#A6ACCD;">解释：你的函数可以返回索引 1，其峰值元素为 2；</span></span>
<span class="line"><span style="color:#A6ACCD;">     或者返回索引 5， 其峰值元素为 6。</span></span></code></pre></div><h3 id="思想-6" tabindex="-1">思想 <a class="header-anchor" href="#思想-6" aria-label="Permalink to &quot;思想&quot;">​</a></h3><ol><li>寻找最大值</li><li>迭代爬坡</li></ol><ul><li>在 <code>[0,n)</code> 的范围内随机一个初始位置 iii，随后根据 <code>nums[i−1],nums[i],nums[i+1]</code> 决定爬的方向</li><li><code>nums[i−1]&lt;nums[i]&gt;nums[i+1]</code>: i 就是峰值，返回i</li><li><code>nums[i−1]&lt;nums[i]&lt;nums[i+1]</code>：i 处于上坡，往右走</li><li><code>nums[i−1]&gt;nums[i]&gt;nums[i+1]</code>：i 处于下坡，往左走</li><li><code>nums[i−1]&gt;nums[i]&lt;nums[i+1]</code>：i处于山谷，两侧都是上坡，任意方向走，我们规定往右</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var findPeakElement = function(nums) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let left = 0</span></span>
<span class="line"><span style="color:#A6ACCD;">    let right = nums.length - 1</span></span>
<span class="line"><span style="color:#A6ACCD;">    while(left&lt;right) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 中间值</span></span>
<span class="line"><span style="color:#A6ACCD;">        const mid = Math.floor((left+right) / 2)</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (nums[mid] &gt; nums[mid+1]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            // 当前元素大于右侧相邻元素，峰值可能在左侧</span></span>
<span class="line"><span style="color:#A6ACCD;">            right = mid</span></span>
<span class="line"><span style="color:#A6ACCD;">        } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">            // 当前元素小于右侧相邻元素，峰值可能在右侧</span></span>
<span class="line"><span style="color:#A6ACCD;">            left = mid+1</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return left</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><h2 id="合并两个有序数组" tabindex="-1">合并两个有序数组 <a class="header-anchor" href="#合并两个有序数组" aria-label="Permalink to &quot;合并两个有序数组&quot;">​</a></h2><h3 id="题目-11" tabindex="-1">题目 <a class="header-anchor" href="#题目-11" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：[1,2,2,3,5,6]</span></span>
<span class="line"><span style="color:#A6ACCD;">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span></span>
<span class="line"><span style="color:#A6ACCD;">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span></span></code></pre></div><h3 id="题解" tabindex="-1">题解 <a class="header-anchor" href="#题解" aria-label="Permalink to &quot;题解&quot;">​</a></h3><ol><li><p>直接合并后排序</p></li><li><p>双指针</p><ul><li>利用双指针每次比较两者中较大的放入公共空间</li></ul><p><img src="/blog/assets/1.60f1aeea.gif" alt="1"></p></li><li><p>逆向双指针</p><ul><li>把两者中较大的值放到数组的末尾</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var merge = function (nums1, m, nums2, n) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  let l = m - 1;</span></span>
<span class="line"><span style="color:#A6ACCD;">  let r = n - 1;</span></span>
<span class="line"><span style="color:#A6ACCD;">  let tail = m + n - 1;</span></span>
<span class="line"><span style="color:#A6ACCD;">  let cur;</span></span>
<span class="line"><span style="color:#A6ACCD;">  while (l &gt;= 0 || r &gt;= 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (l === -1) {</span></span>
<span class="line"><span style="color:#A6ACCD;">      cur = nums2[r--];</span></span>
<span class="line"><span style="color:#A6ACCD;">    } else if (r === -1) {</span></span>
<span class="line"><span style="color:#A6ACCD;">      cur = nums1[l--];</span></span>
<span class="line"><span style="color:#A6ACCD;">    } else if (nums1[l] &gt; nums2[r]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">      cur = nums1[l--];</span></span>
<span class="line"><span style="color:#A6ACCD;">    } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">      cur = nums2[r--];</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    nums1[tail--] = cur;</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div></li></ol><h2 id="移除元素" tabindex="-1">移除元素 <a class="header-anchor" href="#移除元素" aria-label="Permalink to &quot;移除元素&quot;">​</a></h2><h3 id="题目-12" tabindex="-1">题目 <a class="header-anchor" href="#题目-12" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h3 id="题解-1" tabindex="-1">题解 <a class="header-anchor" href="#题解-1" aria-label="Permalink to &quot;题解&quot;">​</a></h3><ol><li><p>拷贝覆盖</p><ul><li>设置下标 ans，遍历数组，当遍历元素不等于 val，则ans自增1，则得到新的数组长度</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var removeElement = function (nums, val) {</span></span>
<span class="line"><span style="color:#A6ACCD;"> let ans = 0;</span></span>
<span class="line"><span style="color:#A6ACCD;"> for (const num of nums) {</span></span>
<span class="line"><span style="color:#A6ACCD;">     if (num != val) {</span></span>
<span class="line"><span style="color:#A6ACCD;">     nums[ans] = num;</span></span>
<span class="line"><span style="color:#A6ACCD;">     ans++;</span></span>
<span class="line"><span style="color:#A6ACCD;">     }</span></span>
<span class="line"><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#A6ACCD;"> return ans;</span></span>
<span class="line"><span style="color:#A6ACCD;"> };</span></span></code></pre></div></li><li><p>双指针原地移除</p><ul><li>如果左指针 left 指向的元素等于val，此时将右指针 right 指向的元素复制到左指针left 的位置，然后右指针 right 左移一位</li><li>如果赋值过来的元素恰好也等于 val，可以继续把右指针right 指向的元素的值赋值过来（左指针 left 指向的等于val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于val 为止</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var removeElement = function (nums, val) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  let left = 0;</span></span>
<span class="line"><span style="color:#A6ACCD;">  let right = nums.length;</span></span>
<span class="line"><span style="color:#A6ACCD;">  while (left &lt; right) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (nums[left] === val) {</span></span>
<span class="line"><span style="color:#A6ACCD;">      nums[left] = nums[right - 1];</span></span>
<span class="line"><span style="color:#A6ACCD;">      right--;</span></span>
<span class="line"><span style="color:#A6ACCD;">    } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">      left++;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">  return left;</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div></li></ol><h2 id="删除有序数组中的重复项" tabindex="-1">删除有序数组中的重复项 <a class="header-anchor" href="#删除有序数组中的重复项" aria-label="Permalink to &quot;删除有序数组中的重复项&quot;">​</a></h2><h3 id="题目-13" tabindex="-1">题目 <a class="header-anchor" href="#题目-13" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</p><p>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</p><p>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span></span>
<span class="line"><span style="color:#A6ACCD;">输出：5, nums = [0,1,2,3,4]</span></span>
<span class="line"><span style="color:#A6ACCD;">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span></span></code></pre></div><h3 id="思路-4" tabindex="-1">思路 <a class="header-anchor" href="#思路-4" aria-label="Permalink to &quot;思路&quot;">​</a></h3><p>拷贝覆盖，设置不重复的下标ans，由于是升序，则当目前item和前一个item不一样时则代表不重复，ans+1同时设置数组下标的新值，由于下标从0开始，则长度时ans+1</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var removeDuplicates = function(nums) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    let ans = 0</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let i=1; i&lt;nums.length; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (nums[i] !== nums[i-1]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            nums[++ans] = nums[i]</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    return ans+1</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div></div></div></main><footer class="VPDocFooter" data-v-a3c25e27 data-v-5774f702><!--[--><!--]--><div class="edit-info" data-v-5774f702><!----><div class="last-updated" data-v-5774f702><p class="VPLastUpdated" data-v-5774f702 data-v-b89b6307>Last updated: <time datetime="2023-09-06T07:34:37.000Z" data-v-b89b6307></time></p></div></div><nav class="prev-next" data-v-5774f702><div class="pager" data-v-5774f702><!----></div><div class="pager" data-v-5774f702><a class="pager-link next" href="/blog/alg/slidewindow.html" data-v-5774f702><span class="desc" data-v-5774f702>Next page</span><span class="title" data-v-5774f702>滑动窗口</span></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"readme.md\":\"9fe2bbf2\",\"alg_sorting.md\":\"a154f413\",\"alg_range.md\":\"8d32dc43\",\"alg_linkedlist.md\":\"0f92f789\",\"article_project_modulestandard.md\":\"a4d90dae\",\"alg_slidewindow.md\":\"93e95a53\",\"alg_dobulepointer.md\":\"10fe8b2e\",\"readme.en.md\":\"eaadeb5d\",\"interview_miniwechat.md\":\"d977b9d2\",\"interview_experience.md\":\"3ad3d0c4\",\"interview_lightspot.md\":\"b28e8643\",\"alg_array.md\":\"285e035c\",\"article_vue3_vueuse.md\":\"59ec69d1\",\"interview_html.md\":\"5e20e85b\",\"code_vue3_vue-use-demo_readme.md\":\"e9f77e28\",\"article_vuecomponent_usets.md\":\"180b5915\",\"article_requirement_upload.md\":\"1e075c3d\",\"interview_codeconsole.md\":\"126c0a41\",\"article_vuecomponent_monorepo.md\":\"4e04216a\",\"article_wheel_lazyload.md\":\"a0116601\",\"alg_stack.md\":\"17dd5b1b\",\"article_wheel_scrolllist.md\":\"bff814f0\",\"article_react_reactusecss.md\":\"39956f95\",\"interview_css.md\":\"2d3d234d\",\"article_react_reactusets.md\":\"2fea022f\",\"article_vuecomponent_bem.md\":\"f76ce9fa\",\"article_react_reactbasic.md\":\"8e73c160\",\"article_react_reactrouter.md\":\"94c71e5e\",\"interview_performance.md\":\"aa01da1f\",\"article_requirement_binary.md\":\"1e140587\",\"interview_softskill.md\":\"a807d4aa\",\"article_project_rollup_vite.md\":\"b8518f6c\",\"index.md\":\"a4192508\",\"article_precipitation_eventbus.md\":\"5c1cea8e\",\"article_vue3_vue3stage.md\":\"af3adaba\",\"node_nodebasic.md\":\"08b016d6\",\"node_mongodb.md\":\"f60d5598\",\"interview_network.md\":\"f266486d\",\"node_clitheory.md\":\"58c57dcc\",\"article_react_reactstateman.md\":\"8c592660\",\"node_express.md\":\"9049c5ac\",\"alg_hash.md\":\"0ed1699c\",\"node_koa.md\":\"cce0fcff\",\"interview_vue.md\":\"60363d6c\",\"article_react_reacthooks.md\":\"a7b6f542\",\"article_project_webpackconfig.md\":\"72ec81d1\",\"interview_networkinterview.md\":\"6d09c46c\",\"interview_writecode.md\":\"66b6deb5\",\"node_clibasic.md\":\"69352717\",\"article_project_normalizeconfig.md\":\"39d23d0b\",\"interview_monitor.md\":\"79b39e4f\",\"interview_javascript.md\":\"6a379c53\",\"interview_browser.md\":\"e4f87485\",\"interview_typescript.md\":\"91b27097\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"well's blog\",\"description\":\"well's blog\",\"base\":\"/blog/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"lastUpdated\":\"最后更新时间\",\"docsDir\":\"docs\",\"editLinks\":true,\"editLinkText\":\"编辑此网站\",\"repo\":\"https://gitee.com/wayliuhaha/blog\",\"nav\":[{\"text\":\"文档\",\"link\":\"/article/project/normalizeConfig\",\"activeMatch\":\"/article/\"},{\"text\":\"node\",\"link\":\"/node/nodeBasic\",\"activeMatch\":\"/node/\"},{\"text\":\"不止于面试\",\"link\":\"/interview/css\",\"activeMatch\":\"/interview/\"},{\"text\":\"算法\",\"link\":\"/alg/array\",\"activeMatch\":\"/alg/\"}],\"sidebar\":{\"/node/\":[{\"text\":\"node 基础\",\"link\":\"/node/nodeBasic\"},{\"text\":\"mongoDB\",\"link\":\"/node/mongoDB\"},{\"text\":\"express\",\"link\":\"/node/express\"},{\"text\":\"koa\",\"link\":\"/node/koa\"},{\"text\":\"脚手架实现原理\",\"link\":\"/node/cliTheory\"},{\"text\":\"脚手架基础\",\"link\":\"/node/cliBasic\"}],\"/article/\":[{\"text\":\"文档\",\"items\":[{\"text\":\"项目工程化\",\"items\":[{\"text\":\"规范化配置\",\"link\":\"/article/project/normalizeConfig\"},{\"text\":\"打包工具-webpack\",\"link\":\"/article/project/webpackConfig\"},{\"text\":\"rollup&webpack\",\"link\":\"/article/project/rollup&vite\"},{\"text\":\"前端模块化规范\",\"link\":\"/article/project/moduleStandard\"}]},{\"text\":\"轮子原理\",\"items\":[{\"text\":\"图片懒加载\",\"link\":\"/article/wheel/lazyload\"},{\"text\":\"虚拟滚动列表\",\"link\":\"/article/wheel/scrollList\"}]},{\"text\":\"vue3 通用组件\",\"items\":[{\"text\":\"Monorepo\",\"link\":\"/article/vueComponent/monorepo\"},{\"text\":\"ts 类型约束\",\"link\":\"/article/vueComponent/usets \"},{\"text\":\"BEM 规范\",\"link\":\"/article/vueComponent/bem\"}]},{\"text\":\"React\",\"items\":[{\"text\":\"react 基础\",\"link\":\"/article/react/reactBasic\"},{\"text\":\"react hooks\",\"link\":\"/article/react/reactHooks\"},{\"text\":\"react 使用ts指南\",\"link\":\"/article/react/reactUseTs\"},{\"text\":\"react 使用css\",\"link\":\"/article/react/reactUseCss\"},{\"text\":\"reactRouter\",\"link\":\"/article/react/reactRouter\"},{\"text\":\"react 状态管理\",\"link\":\"/article/react/reactStateMan\"}]},{\"text\":\"常见需求处理\",\"items\":[{\"text\":\"二进制\",\"link\":\"/article/requirement/binary\"},{\"text\":\"文件上传\",\"link\":\"/article/requirement/upload\"}]},{\"text\":\"沉淀\",\"items\":[{\"text\":\"EventBus 手写\",\"link\":\"/article/precipitation/eventbus\"}]},{\"text\":\"vue3\",\"items\":[{\"text\":\"手写vue3核心原理\",\"link\":\"/article/vue3/vue3stage\"},{\"text\":\"vueUse 源码解析\",\"link\":\"/article/vue3/vueuse\"}]}]}],\"/interview\":[{\"text\":\"不止于面试\",\"items\":[{\"text\":\"css\",\"link\":\"/interview/css\"},{\"text\":\"html\",\"link\":\"/interview/html\"},{\"text\":\"javascript\",\"link\":\"/interview/javascript\"},{\"text\":\"typescript\",\"link\":\"/interview/typescript\"},{\"text\":\"vue\",\"link\":\"/interview/vue\"},{\"text\":\"代码输出\",\"link\":\"/interview/codeconsole\"},{\"text\":\"手写代码\",\"link\":\"/interview/writecode\"},{\"text\":\"浏览器原理\",\"link\":\"/interview/browser\"},{\"text\":\"计算机网络\",\"link\":\"/interview/network\"},{\"text\":\"计算机网络（面试）\",\"link\":\"/interview/networkinterview\"},{\"text\":\"微信小程序\",\"link\":\"/interview/miniwechat\"},{\"text\":\"性能优化\",\"link\":\"/interview/performance\"},{\"text\":\"监控平台\",\"link\":\"/interview/monitor\"},{\"text\":\"难点亮点\",\"link\":\"/interview/lightspot\"},{\"text\":\"软技能\",\"link\":\"/interview/softskill\"},{\"text\":\"面经\",\"link\":\"/interview/experience\"}]}],\"/alg\":[{\"text\":\"算法\",\"items\":[{\"text\":\"数组/字符串\",\"link\":\"/alg/array\"},{\"text\":\"滑动窗口\",\"link\":\"/alg/slidewindow\"},{\"text\":\"哈希表\",\"link\":\"/alg/hash\"},{\"text\":\"双指针\",\"link\":\"/alg/dobulePointer\"},{\"text\":\"栈\",\"link\":\"/alg/stack\"},{\"text\":\"区间\",\"link\":\"/alg/range\"},{\"text\":\"链表\",\"link\":\"/alg/linkedList\"},{\"text\":\"排序算法\",\"link\":\"/alg/sorting\"}]}]}},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}");</script>
    
  </body>
</html>